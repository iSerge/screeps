module.exports = {"version":3,"sources":["webpack/bootstrap","./src/limits.ts","./src/main.ts","./src/role.builder.ts","./src/role.carrier.ts","./src/role.claimer.ts","./src/role.harvester.ts","./src/role.upgrader.ts","./src/roles.ts","./src/utils.ts","external \"lodash\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","limits","builder","carrier","claimer","harvester","upgrader","_","roles_1","utils_1","main","LoopFunctions","findDamagedStructures","forOwn","Game","rooms","room","find","FIND_STRUCTURES","filter","struct","structureType","STRUCTURE_WALL","hits","Memory","maxWallHits","STRUCTURE_RAMPART","maxRampartHits","STRUCTURE_CONTAINER","hitsMax","utils","enqueueStructure","towerLogic","structures","STRUCTURE_TOWER","tower_1","closestHostile","pos","findClosestByRange","FIND_HOSTILE_CREEPS","creep","inRangeTo","memory","towerActive","attack","closestDamagedCreep","FIND_MY_CREEPS","heal","energy","closestDamagedStructure","structure","repair","damagedCreep","creepActions","creeps","rolesModule","run","loop","updateInfrastructure","clearMemory","countCreeps","controller","getOwnPropertyNames","length","spawnQueue","unshift","body","CARRY","MOVE","role","CARRIER","WORK","HARVESTER","spawn","spawns","processSpawnQueue","spawning","spawningCreep","visual","text","Messages","CONSTRUCT_SYM","x","y","align","opacity","Builder","availEnergy","target","tryBuildRoad","building","energyTarget","navigateToDesignatedRoom","operateInRoom","carry","say","HARVEST","carryCapacity","BUILD","getObjectById","buildTarget","shiftStructure","findConstructionSite","id","Structure","ERR_NOT_IN_RANGE","moveTo","ConstructionSite","build","getEnergyStorageTarget","src","findInRange","getEnergy","RoomPosition","type","sites","constructionSites","site","roomName","findClosestByPath","roleBuilder","Carrier","parts","Math","floor","Array","moveParts","ceil","hauling","PICKUP","DISTRIBUTE","this","getStoreTarget","transfer","RESOURCE_ENERGY","getEnergyTarget","Source","drops","FIND_DROPPED_RESOURCES","drop","resourceType","amount","sortBy","conts","cont","controllerCont","store","storeCapacity","FIND_MY_STRUCTURES","STRUCTURE_STORAGE","FIND_SOURCES_ACTIVE","maxOps","FIND_SOURCES","energyAvailable","energyCapacityAvailable","STRUCTURE_SPAWN","energyCapacity","STRUCTURE_EXTENSION","ext","designatedRoom","isNull","towers","tower","roleCarrier","Claimer","CLAIM","flag","flags","sameRoom","structs","lookForAt","LOOK_STRUCTURES","forEach","str","STRUCTURE_CONTROLLER","claimTarget","my","attackController","claimController","OK","reserveController","roleClaimer","Harvester","findSource","console","log","harvestedSources","dst","STRUCTURE_LINK","harvest","roleHarvester","Upgrader","upgrading","UPGRADE","upgradeController","roleUpgrader","limits_1","role_builder_1","role_carrier_1","role_claimer_1","role_harvester_1","role_upgrader_1","BUILDER","CLAIMER","UPGRADER","roles","RolesModule","roleName","roomMem","creepCount","spec","shift","JSON","stringify","canCreateCreep","newName","createCreep","undefined","push","_this","limit","isUndefined","Utils","buildPriority","priority","includes","repairQueue","result","Resource","pickup","withdraw","targets","res","concat","ERR_NOT_FOUND","noPathFinding","visualizePathStyle","stroke","reusePath","own","needsRepair","autoBuildRoads","lookAt","obj","STRUCTURE_ROAD","LOOK_CONSTRUCTION_SITES","createConstructionSite","require"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {Dictionary} from \"lodash\";\r\n\r\nexport const limits: Dictionary<number> = {\r\n    builder:   2,\r\n    carrier:   3,\r\n    claimer:   2,\r\n    harvester: 2,\r\n    upgrader:  2\r\n};\r\n","import * as _ from \"lodash\";\r\n\r\nimport {CARRIER, HARVESTER, rolesModule as roles} from \"./roles\";\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nclass LoopFunctions {\r\n    public findDamagedStructures() {\r\n        _.forOwn(Game.rooms, (room) => {\r\n            room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if ((struct.structureType === STRUCTURE_WALL && struct.hits < Memory.maxWallHits) ||\r\n                        (struct.structureType === STRUCTURE_RAMPART && struct.hits < Memory.maxRampartHits / 2) ||\r\n                        (struct.structureType === STRUCTURE_CONTAINER && struct.hits < struct.hitsMax - 50000) ||\r\n                        (struct.structureType !== STRUCTURE_RAMPART && struct.structureType !== STRUCTURE_WALL &&\r\n                            struct.hits < struct.hitsMax / 2)) { utils.enqueueStructure(room, struct); }\r\n                    return false;\r\n                }}); });\r\n    }\r\n\r\n    public towerLogic() {\r\n        _.forOwn(Game.structures, (struct: Structure) => {\r\n            if (struct.structureType === STRUCTURE_TOWER) {\r\n                const tower = struct as StructureTower;\r\n                const closestHostile: Creep | null = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.pos.inRangeTo(tower.pos, tower.room.memory.towerActive ? 15 : 7);\r\n                    }\r\n                });\r\n                if (closestHostile) {\r\n                    tower.room.memory.towerActive = true;\r\n                    tower.attack(closestHostile);\r\n                } else {\r\n                    tower.room.memory.towerActive = false;\r\n                }\r\n\r\n                const closestDamagedCreep: Creep | null = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.hits < creep.hitsMax / 3;\r\n                    }\r\n                });\r\n                if (closestDamagedCreep) {\r\n                    tower.heal(closestDamagedCreep);\r\n                }\r\n\r\n                if (700 < tower.energy) {\r\n                    const closestDamagedStructure: Structure | null = tower.pos.findClosestByRange(FIND_STRUCTURES, {\r\n                        filter: (structure: Structure) => {\r\n                            return (structure.structureType === STRUCTURE_RAMPART &&\r\n                                    structure.hits < Memory.maxRampartHits)\r\n                                || (structure.structureType !== STRUCTURE_WALL &&\r\n                                    structure.structureType !== STRUCTURE_RAMPART &&\r\n                                    structure.hits < structure.hitsMax / 3);\r\n                        }\r\n                    });\r\n                    if (closestDamagedStructure) {\r\n                        tower.repair(closestDamagedStructure);\r\n                    }\r\n                }\r\n\r\n                // if nothing to do heal damaged creeps\r\n                const damagedCreep: Creep | null = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.hits < creep.hitsMax;\r\n                    }\r\n                });\r\n                if (damagedCreep) {\r\n                    tower.heal(damagedCreep);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public creepActions() {\r\n        _.forOwn(Game.creeps, (creep) => {\r\n            roles.run(creep);\r\n        });\r\n    }\r\n}\r\n\r\nconst main = new LoopFunctions();\r\n\r\nmodule.exports.loop = () => {\r\n    utils.updateInfrastructure();\r\n\r\n    utils.clearMemory();\r\n\r\n    main.findDamagedStructures();\r\n\r\n    roles.countCreeps();\r\n\r\n    _.forOwn(Game.rooms, (room) => {\r\n        if (room.controller) {\r\n\r\n            if (Object.getOwnPropertyNames(Game.creeps).length === 0) {\r\n                room.memory.spawnQueue = [];\r\n                room.memory.spawnQueue.unshift({\r\n                    body: [CARRY, MOVE],\r\n                    role: CARRIER\r\n                });\r\n                room.memory.spawnQueue.unshift({\r\n                    body: [CARRY, WORK, WORK, MOVE],\r\n                    role: HARVESTER\r\n                });\r\n            }\r\n\r\n            roles.spawn(room);\r\n        }\r\n    });\r\n\r\n    _.forOwn(Game.spawns, (spawn) => {\r\n        roles.processSpawnQueue(spawn);\r\n\r\n        if (spawn.spawning) {\r\n            const spawningCreep = Game.creeps[spawn.spawning.name];\r\n            spawn.room.visual.text(\r\n                Messages.CONSTRUCT_SYM + \" \" + spawningCreep.memory.role,\r\n                spawn.pos.x + 1,\r\n                spawn.pos.y,\r\n                {align: \"left\", opacity: 0.8});\r\n        }\r\n    });\r\n\r\n    main.towerLogic();\r\n\r\n    main.creepActions();\r\n};\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Builder implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, CARRY, CARRY, MOVE]; // 250\r\n        } else if (availEnergy < 450) {\r\n            return [WORK, CARRY, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 550) {\r\n            return [WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE]; // 450\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE]; // 550\r\n        } else if (availEnergy < 650) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else if (availEnergy < 750) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE]; // 650\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE]; // 750\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (!creep.memory.building && !creep.memory.energyTarget && utils.navigateToDesignatedRoom(creep)\r\n            && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n            return;\r\n        }\r\n\r\n        if (creep.memory.building && creep.carry.energy === 0) {\r\n            creep.memory.building = false;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.HARVEST);\r\n        }\r\n\r\n        if (!creep.memory.building && creep.carry.energy === creep.carryCapacity) {\r\n            creep.memory.building = true;\r\n            creep.say(Messages.BUILD);\r\n        }\r\n\r\n        if (creep.memory.building) {\r\n            let target = Game.getObjectById(creep.memory.buildTarget) as Structure | ConstructionSite | null;\r\n            if (!target) {\r\n                target = utils.shiftStructure(creep, true);\r\n\r\n                if (!target) {\r\n                    target = utils.findConstructionSite(creep);\r\n                }\r\n\r\n                if (!target) {\r\n                    target = utils.shiftStructure(creep, false);\r\n                }\r\n\r\n                if (target) {\r\n                    creep.memory.buildTarget = target.id;\r\n                } else {\r\n                    creep.say(\"\\uD83D\\uDEA7 nothing\");\r\n                    creep.memory.buildTarget = \"\";\r\n                    creep.memory.energyTarget = \"\";\r\n                    creep.memory.building = false;\r\n                }\r\n            }\r\n\r\n            if (target instanceof Structure) {\r\n                if ((target.structureType !== STRUCTURE_WALL &&\r\n                        target.structureType !== STRUCTURE_RAMPART && target.hits < target.hitsMax) ||\r\n                    (target.structureType === STRUCTURE_WALL && target.hits < Memory.maxWallHits) ||\r\n                    (target.structureType === STRUCTURE_RAMPART && target.hits < Memory.maxRampartHits)) {\r\n                    if (creep.repair(target) === ERR_NOT_IN_RANGE) {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                } else {\r\n                    creep.memory.buildTarget = \"\";\r\n                    creep.memory.building = false;\r\n                }\r\n            } else if (target instanceof ConstructionSite) {\r\n                if (creep.build(target) === ERR_NOT_IN_RANGE) {\r\n                    utils.moveTo(creep, target.pos);\r\n                }\r\n            } else {\r\n                creep.memory.buildTarget = \"\";\r\n                creep.memory.building = false;\r\n            }\r\n        } else {\r\n            if (creep.carry.energy < creep.carryCapacity) {\r\n                const target = utils.getEnergyStorageTarget(creep);\r\n                if (target) {\r\n                    const src = creep.pos.findInRange([target], 1);\r\n                    if (src.length) {\r\n                        utils.getEnergy(creep, src[0]);\r\n                    } else {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                } else {\r\n                    creep.say(\"No energy\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {Creep} creep\r\n     * @returns {ConstructionSite}\r\n     */\r\n    private findConstructionSite(type: StructureConstant, creep: Creep) {\r\n        let target = null;\r\n\r\n        const sites = _.filter(Game.constructionSites, (site: ConstructionSite) => {\r\n            return  site.structureType === type && site.pos.roomName === creep.memory.operateInRoom;\r\n        });\r\n\r\n        if (sites.length) {\r\n            target = creep.pos.findClosestByPath(sites);\r\n            if (!target) {\r\n                target = sites[0];\r\n            }\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n}\r\n\r\nexport const roleBuilder: Role = new Builder();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\n/**\r\n *\r\n * @class\r\n * @extends {Role}\r\n */\r\nclass Carrier implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        let parts;\r\n        if (availEnergy < 300) {\r\n            parts = 6;\r\n        } else if (750 < availEnergy) {\r\n            parts = 15;\r\n        } else {\r\n            parts = Math.floor(availEnergy / 50);\r\n        }\r\n\r\n        const body = new Array(parts);\r\n        const moveParts = Math.ceil(parts / 3);\r\n\r\n        for (let i = 0; i < parts; ++i) {\r\n            body[i] = i < moveParts ? MOVE : CARRY;\r\n        }\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (!creep.memory.hauling && !creep.memory.energyTarget && utils.navigateToDesignatedRoom(creep)\r\n             && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n            return;\r\n        }\r\n\r\n        if (creep.memory.hauling && creep.carry.energy === 0) {\r\n            creep.memory.hauling = false;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.PICKUP);\r\n        }\r\n\r\n        if (!creep.memory.hauling && creep.carry.energy === creep.carryCapacity) {\r\n            creep.memory.hauling = true;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.DISTRIBUTE);\r\n        }\r\n\r\n        if (creep.memory.hauling) {\r\n            const target = this.getStoreTarget(creep);\r\n            if (target && creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            } else {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        } else {\r\n            const target = this.getEnergyTarget(creep);\r\n            if (target && utils.getEnergy(creep, target) === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            } else {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {Resource|Source|Structure}\r\n     */\r\n    private getEnergyTarget(creep: Creep): Resource | Source | Structure | null {\r\n        let target: Structure | Resource | Source | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (target instanceof Source && creep.pos.inRangeTo(target.pos, 2)) {\r\n            target = null;\r\n        }\r\n\r\n        if (!target) {\r\n            // dropped energy\r\n            const drops: Resource[] = creep.room.find(FIND_DROPPED_RESOURCES, {\r\n                filter: (drop: Resource) => {\r\n                    return drop.resourceType === RESOURCE_ENERGY && 50 < drop.amount;\r\n                }\r\n            });\r\n\r\n            target = _.sortBy(drops, (drop: Resource) => {\r\n                return -drop.amount;\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            // containers near sources\r\n            const conts: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_CONTAINER) {\r\n                        const cont = struct as StructureContainer;\r\n                        return cont.id !== creep.room.memory.controllerCont && 20 < cont.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n\r\n            // most full container\r\n            target = _.sortBy(conts, (cont) => {\r\n                if (cont.structureType === STRUCTURE_CONTAINER) {\r\n                    const c = cont as StructureContainer;\r\n                    return c.storeCapacity - c.store.energy;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            const targets: Structure[] = creep.room.find(FIND_MY_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_STORAGE) {\r\n                        const store = struct as StructureStorage;\r\n                        return store.structureType === STRUCTURE_STORAGE && 0 < store.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n\r\n                }\r\n            });\r\n            target = targets[0];\r\n        }\r\n\r\n        if (!target) {\r\n            target = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE, {\r\n                maxOps: 100\r\n            });\r\n            if (!target) {\r\n                const targets: Source[] = creep.room.find(FIND_SOURCES);\r\n                target = targets[0];\r\n            }\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {Spawn|Structure}\r\n     */\r\n    private getStoreTarget(creep: Creep): Creep | Structure | null {\r\n        let target: Creep | Structure | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for spawns and extensions');\r\n            if (creep.room.energyAvailable < creep.room.energyCapacityAvailable) {\r\n                target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\r\n                    filter: (s: Structure) => {\r\n                        switch (s.structureType) {\r\n                            case STRUCTURE_SPAWN:\r\n                                const spawn = s as StructureExtension;\r\n                                return spawn.energy < spawn.energyCapacity\r\n                                    && creep.memory.operateInRoom === spawn.pos.roomName;\r\n                            case STRUCTURE_EXTENSION:\r\n                                const ext = s as StructureExtension;\r\n                                return ext.energy < ext.energyCapacity\r\n                                    && creep.memory.operateInRoom === ext.pos.roomName;\r\n                                default:\r\n                                return false;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n            // console.log('Harvester ' + creep.name + ' harvesting target: ' + target.id);\r\n\r\n        if (!target) {\r\n            // containers near controllers\r\n            // console.log('Carrier ' + creep.name + ' looking for controller container');\r\n\r\n            const designatedRoom = Game.rooms[creep.memory.operateInRoom];\r\n\r\n            const cont: StructureContainer | null =\r\n                !_.isNull(designatedRoom) ? Game.getObjectById(designatedRoom.memory.controllerCont) : null;\r\n            if (cont && 500 < cont.storeCapacity - cont.store.energy) {\r\n                target = cont;\r\n            }\r\n        }\r\n\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for towers');\r\n            const towers: Structure[] = _.filter(Game.structures, (struct: Structure) => {\r\n                if (STRUCTURE_TOWER === struct.structureType) {\r\n                    const tower = struct as StructureTower;\r\n                    return tower.room.name === creep.memory.operateInRoom &&\r\n                    0 <= tower.energyCapacity - tower.energy - 300;\r\n                } else {\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            // emptiest tower\r\n            target = _.sortBy(towers, (struct) => {\r\n                if (struct.structureType === STRUCTURE_CONTAINER) {\r\n                    const tower = struct as StructureTower;\r\n                    return tower.energyCapacity + tower.energy;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            // looking for storage\r\n            // console.log('Carrier ' + creep.name + ' looking for storage');\r\n            const storages: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_STORAGE) {\r\n                        const store = struct as StructureStorage;\r\n                        return 0 < store.storeCapacity - store.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n            target = storages[0];\r\n        }\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for sources');\r\n\r\n            const targets: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    switch (struct.structureType) {\r\n                        case STRUCTURE_EXTENSION:\r\n                            const ext = struct as StructureExtension;\r\n                            return ext.energy < ext.energyCapacity && creep.memory.operateInRoom === ext.pos.roomName;\r\n                        case STRUCTURE_SPAWN:\r\n                            const spawn = struct as StructureSpawn;\r\n                            return spawn.energy < spawn.energyCapacity\r\n                                && creep.memory.operateInRoom === spawn.pos.roomName;\r\n                        default:\r\n                            return false;\r\n                    }\r\n\r\n                }\r\n            });\r\n            target = targets[0];\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n}\r\n\r\nexport const roleCarrier: Role = new Carrier();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\n/**\r\n *\r\n * @class\r\n * @extends {Role}\r\n */\r\nclass Claimer implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 1400) {\r\n            return [MOVE, MOVE, CLAIM];\r\n        } else if (availEnergy < 2100) {\r\n            return [MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM];\r\n        } else if (availEnergy < 2800) {\r\n            return [MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM, CLAIM];\r\n        } else {\r\n            return [MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM, CLAIM, CLAIM];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        let flag = Game.flags[\"claim\"];\r\n        if (!flag) {\r\n            flag = Game.flags[\"reserve\"];\r\n        }\r\n\r\n        const sameRoom = flag && creep.room.name === flag.pos.roomName;\r\n\r\n        if (!flag) {\r\n            delete(creep.memory.claimTarget);\r\n        }\r\n\r\n        if (flag && !sameRoom) {\r\n            utils.moveTo(creep, flag.pos);\r\n        }\r\n\r\n        if (flag && sameRoom) {\r\n            const structs = creep.room.lookForAt(LOOK_STRUCTURES, flag.pos);\r\n            if (structs.length) {\r\n                _.forEach(structs, (str: Structure) => {\r\n                    if (str.structureType === STRUCTURE_CONTROLLER) {\r\n                        creep.memory.claimTarget = str.id;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (creep.memory.claimTarget) {\r\n            // Move to target & claim\r\n            const controller: StructureController | null = Game.getObjectById(creep.memory.claimTarget);\r\n            if (controller) {\r\n                if (flag.name === \"claim\") {\r\n                    if (creep.room.controller && !creep.room.controller.my) {\r\n                        if (creep.attackController(creep.room.controller) === ERR_NOT_IN_RANGE) {\r\n                            creep.moveTo(creep.room.controller);\r\n                        }\r\n                    } else {\r\n                        if (creep.claimController(controller) !== OK) {\r\n                            utils.moveTo(creep, controller.pos);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (creep.reserveController(controller) !== OK) {\r\n                        utils.moveTo(creep, controller.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const roleClaimer: Role = new Claimer();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Harvester implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, WORK, CARRY, MOVE]; // 300\r\n        } else if (availEnergy < 400) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 500) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 400\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 500\r\n        } else if (availEnergy < 700) {\r\n            return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 700\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        let target: Source | null = Game.getObjectById(creep.memory.target);\r\n\r\n        if (!target) {\r\n\r\n            target = this.findSource(creep);\r\n\r\n            if (target) {\r\n\r\n                if (target.room.name !== creep.room.name) {\r\n                    console.log(\"Harvester found target in other room: \" + target.room);\r\n                }\r\n\r\n                Memory.harvestedSources[target.id] = target.id;\r\n                creep.memory.target = target.id;\r\n                creep.say(Messages.HARVEST);\r\n            }\r\n        }\r\n\r\n        if (0 < creep.carry.energy) {\r\n            // console.log('Harvester ' + creep.name + ' unloading');// JSON.stringify(target, null, 4));\r\n            const dst: Structure[] = creep.pos.findInRange(FIND_STRUCTURES, 1, {\r\n                filter: (struct: StructureLink | StructureContainer) => {\r\n                    return (struct.structureType === STRUCTURE_LINK && struct.energy < struct.energyCapacity) ||\r\n                        (struct.structureType === STRUCTURE_CONTAINER && struct.store.energy < struct.storeCapacity);\r\n                }\r\n            });\r\n\r\n            if (dst.length) {\r\n                creep.transfer(dst[0], RESOURCE_ENERGY);\r\n            } else {\r\n                creep.drop(RESOURCE_ENERGY);\r\n            }\r\n        }\r\n        // console.log('Harvester ' + creep.name + ' harvesting target: ' + target.id);\r\n        // JSON.stringify(target, null, 4));\r\n        if (target) {\r\n            const err = creep.harvest(target);\r\n            if (err === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private findSource(creep: Creep): Source | null {\r\n        const sources: Source[] = creep.room.find(FIND_SOURCES, {\r\n            filter: (src: Source) => {\r\n                return !Memory.harvestedSources.hasOwnProperty(src.id);\r\n            }\r\n        });\r\n\r\n        return sources[0];\r\n    }\r\n}\r\n\r\nexport const roleHarvester: Role = new Harvester();\r\n","import {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Upgrader implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, CARRY, MOVE, MOVE]; // 250\r\n        } else if (availEnergy < 400) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 500) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 400\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 500\r\n        } else if (availEnergy < 700) {\r\n            return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 700\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (utils.navigateToDesignatedRoom(creep) && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n        } else {\r\n            if (creep.memory.upgrading && creep.carry.energy === 0) {\r\n                creep.memory.upgrading = false;\r\n                creep.say(Messages.HARVEST);\r\n            }\r\n            if (!creep.memory.upgrading && creep.carry.energy === creep.carryCapacity) {\r\n                creep.memory.upgrading = true;\r\n                creep.memory.energyTarget = \"\";\r\n                creep.say(Messages.UPGRADE);\r\n            }\r\n\r\n            if (creep.memory.upgrading && creep.room.controller) {\r\n                if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {\r\n                    utils.moveTo(creep, creep.room.controller.pos);\r\n                }\r\n            } else {\r\n                const target = utils.getEnergyStorageTarget(creep);\r\n                if (target) {\r\n                    const src = creep.pos.findInRange([target], 1);\r\n                    if (src.length) {\r\n                        utils.getEnergy(creep, src[0]);\r\n                    } else {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const roleUpgrader: Role = new Upgrader();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {limits} from \"./limits\";\r\nimport {Role} from \"./Role\";\r\n\r\nimport {roleBuilder} from \"./role.builder\";\r\nimport {roleCarrier} from \"./role.carrier\";\r\nimport {roleClaimer} from \"./role.claimer\";\r\nimport {roleHarvester} from \"./role.harvester\";\r\nimport {roleUpgrader} from \"./role.upgrader\";\r\n\r\nexport interface Roles extends _.Dictionary<Role> {\r\n    builder: Role;\r\n    carrier: Role;\r\n    claimer: Role;\r\n    harvester: Role;\r\n    upgrader: Role;\r\n}\r\n\r\nexport type CreepRole = keyof Roles;\r\n\r\nexport const BUILDER: CreepRole = \"builder\";\r\nexport const CARRIER: CreepRole = \"carrier\";\r\nexport const CLAIMER: CreepRole = \"claimer\";\r\nexport const HARVESTER: CreepRole = \"harvester\";\r\nexport const UPGRADER: CreepRole = \"upgrader\";\r\n\r\nexport const roles: Roles = {\r\n    builder:   roleBuilder,\r\n    carrier:   roleCarrier,\r\n    claimer:   roleClaimer,\r\n    harvester: roleHarvester,\r\n    upgrader:  roleUpgrader\r\n};\r\n\r\nexport interface BodySpec {\r\n    body: BodyPartConstant[];\r\n    role: CreepRole;\r\n}\r\n\r\nexport class RolesModule {\r\n    public countCreeps() {\r\n        _.forOwn(roles, (role, roleName: string) => {\r\n            _.forOwn(Memory.rooms, (roomMem) => {\r\n                roomMem.creepCount[roleName] = 0;\r\n            });\r\n        });\r\n\r\n        _.forOwn(Game.creeps, (creep) => {\r\n            if (!creep.memory.operateInRoom) {\r\n                Memory.rooms[creep.room.name].creepCount[creep.memory.role] += 1;\r\n            } else {\r\n                Memory.rooms[creep.memory.operateInRoom].creepCount[creep.memory.role] += 1;\r\n            }\r\n        });\r\n\r\n        _.forOwn(Memory.rooms, (roomMem) => {\r\n            _.forEach(roomMem.spawnQueue, (spec) => {\r\n                roomMem.creepCount[spec.role] += 1;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  @type {function}\r\n     *\r\n     *  @param {StructureSpawn} spawn Spawn on which start spawning\r\n     */\r\n    public processSpawnQueue(spawn: StructureSpawn) {\r\n        if (spawn.spawning) {\r\n            return;\r\n        }\r\n\r\n        const room = spawn.room;\r\n        const spec = room.memory.spawnQueue.shift();\r\n        if (spec) {\r\n            console.log(\"Processing spawn Q \" + spawn.name + \" \"\r\n                + JSON.stringify({room: room.name, role: spec.role}));\r\n\r\n            if (spawn.canCreateCreep(spec.body) === OK) {\r\n                const newName = spawn.createCreep(spec.body, undefined, {operateInRoom: room.name, role: spec.role});\r\n                console.log(\"Spawning new \" + spec.role + \": \" + newName);\r\n            } else if (\"claimer\" === spec.role) {\r\n                room.memory.spawnQueue.push(spec);\r\n            } else {\r\n                room.memory.spawnQueue.unshift(spec);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Creep} creep\r\n     */\r\n    public run(creep: Creep) {\r\n        roles[creep.memory.role].run(creep);\r\n    }\r\n\r\n    /**\r\n     *  @type {function}\r\n     *\r\n     *  @param {Room} room\r\n     *  @param {string|object} [role] Role of the new creep\r\n     *  @param {Array<string>} role.body Body of spawning creep\r\n     *  @param {string} role.role Role of spawning creep\r\n     */\r\n    public spawn(room: Room, role?: CreepRole | BodySpec) {\r\n        if (!role) {\r\n            _.forOwn(roles, (r, name: CreepRole) => {\r\n                if (name && room.memory.creepCount[name] < this.limit(name)) {\r\n                    const energy = room.energyAvailable;\r\n\r\n                    const body = r.body(energy);\r\n                    room.memory.spawnQueue.push({ body, role: name });\r\n                }\r\n            });\r\n        } else if (typeof role === \"string\") {\r\n            const energy = room.energyAvailable;\r\n\r\n            const body = roles[role].body(energy);\r\n            room.memory.spawnQueue.push({ body, role });\r\n        } else {\r\n            room.memory.spawnQueue.push(role as BodySpec);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} role\r\n     * @returns {number}\r\n     */\r\n    private limit(role: CreepRole): number {\r\n        if (role === \"claimer\") {\r\n            return _.isUndefined(Game.flags[\"claim\"]) && _.isUndefined(Game.flags[\"reserve\"])  ? 0 : limits[role];\r\n        } else {\r\n            return limits[role];\r\n        }\r\n    }\r\n}\r\n\r\nexport const rolesModule = new RolesModule();\r\n","/*\r\n * Module code goes here. Use 'module.exports' to export things:\r\n * module.exports.thing = 'a thing';\r\n *\r\n * You can import it from another modules like this:\r\n * var mod = require('utils');\r\n * mod.thing == 'a thing'; // true\r\n */\r\n\r\nimport * as _ from \"lodash\";\r\n\r\nimport {limits} from \"./limits\";\r\n\r\nexport const Messages = {\r\n    BUILD: \"\\uD83D\\uDEA7 build\",\r\n    CONSTRUCT_SYM: \"\\uD83D\\uDEE0\",\r\n    DISTRIBUTE: \"\\u2194 distr\",\r\n    HARVEST: \"\\uD83D\\uDD04 harvest\",\r\n    PICKUP: \"\\u2B06 pickup\",\r\n    UPGRADE: \"\\u26A1 upgrade\"\r\n};\r\n\r\nexport class Utils {\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @param {ConstructionSite} site\r\n     * @return {number}\r\n     */\r\n    private static buildPriority(creep: Creep, site: ConstructionSite) {\r\n        let priority;\r\n        switch (site.structureType) {\r\n            case STRUCTURE_SPAWN:\r\n                priority = 1;\r\n                break;\r\n            case STRUCTURE_EXTENSION:\r\n                priority = 2;\r\n                break;\r\n            case STRUCTURE_CONTAINER:\r\n                priority = 3;\r\n                break;\r\n            case STRUCTURE_LINK:\r\n                priority = 4;\r\n                break;\r\n            case STRUCTURE_TOWER:\r\n                priority = 5;\r\n                break;\r\n            case STRUCTURE_STORAGE:\r\n                priority = 6;\r\n                break;\r\n            default:\r\n                priority = 7;\r\n                break;\r\n        }\r\n\r\n        return creep.memory.operateInRoom === site.pos.roomName ? priority : priority + 20;\r\n    }\r\n\r\n    public clearMemory() {\r\n        _.forOwn(Memory.creeps, (creep, name: string) => {\r\n            if (!Game.creeps.hasOwnProperty(name)) {\r\n                if (creep.target) {\r\n                    delete Memory.harvestedSources[creep.target];\r\n                }\r\n\r\n                delete Memory.creeps[name];\r\n            }\r\n        });\r\n\r\n        _.forOwn(Memory.rooms, (room, name: string) => {\r\n            if (!Game.rooms.hasOwnProperty(name)) {\r\n                delete Memory.rooms[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {Room} room\r\n     * @param {object} object\r\n     * @param {string} object.id\r\n     */\r\n    public enqueueStructure(room: Room, object: Structure) {\r\n        if (_.isUndefined(object)) {\r\n            return;\r\n        }\r\n\r\n        if (!_.includes(room.memory.repairQueue, object.id)) {\r\n            room.memory.repairQueue.push(object.id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @return {undefined|ConstructionSite}\r\n     */\r\n    public findConstructionSite(creep: Creep) {\r\n        return _.sortBy(Game.constructionSites, [(site: ConstructionSite) => {\r\n            return Utils.buildPriority(creep, site);\r\n        }])[0];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @param {Resource|Source|Structure} target\r\n     */\r\n    public getEnergy(creep: Creep, target: Resource | Source | Structure) {\r\n        let result;\r\n        if (target instanceof Resource) {\r\n            result = creep.pickup(target);\r\n            if (result === OK) {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        } else if (target instanceof Source) {\r\n            result = creep.harvest(target);\r\n        } else {\r\n            result = creep.withdraw(target, RESOURCE_ENERGY);\r\n            if (result === OK) {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {RoomObject}\r\n     */\r\n    public getEnergyStorageTarget(creep: Creep) {\r\n        let target: Structure | Resource | Source | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (!target) {\r\n            let targets: RoomObject[] = creep.room.find(FIND_DROPPED_RESOURCES, {\r\n                filter: (res: Resource) => {\r\n                    return res.resourceType === RESOURCE_ENERGY;\r\n                }\r\n            });\r\n\r\n            targets = targets.concat(creep.room.find(FIND_MY_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    switch (struct.structureType) {\r\n                        case STRUCTURE_STORAGE:\r\n                            const storage = struct as StructureStorage;\r\n                            return 0 < storage.store[RESOURCE_ENERGY];\r\n                        case STRUCTURE_CONTAINER:\r\n                            const container = struct as StructureContainer;\r\n                            return 0 < container.store[RESOURCE_ENERGY];\r\n                        case STRUCTURE_LINK:\r\n                            const link = struct as StructureLink;\r\n                            return 0 < link.energy;\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n            }));\r\n\r\n            target = creep.pos.findClosestByPath(targets, {\r\n                maxOps: 1000\r\n            }) as Structure;\r\n        }\r\n\r\n        if (!target) {\r\n            target = creep.pos.findClosestByPath(FIND_SOURCES);\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @param {RoomPosition} target\r\n     */\r\n    public moveTo(creep: Creep, target: RoomPosition) {\r\n        if (ERR_NOT_FOUND === creep.moveTo(target, {\r\n                noPathFinding: true,\r\n                visualizePathStyle: {stroke: \"#ffffff\"}\r\n            })) {\r\n            creep.moveTo(target, {\r\n                reusePath: 20,\r\n                visualizePathStyle: {stroke: \"#ffffff\"}\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Creep} creep\r\n     */\r\n    public navigateToDesignatedRoom(creep: Creep) {\r\n        return creep.memory.operateInRoom !== creep.pos.roomName;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @param {boolean} own\r\n     * @return {null|RoomObject}\r\n     */\r\n    public shiftStructure(creep: Creep, own: boolean): Structure | null {\r\n        const roomName = creep.memory.operateInRoom;\r\n        if (0 < Memory.rooms[roomName].repairQueue.length) {\r\n            let id = Game.getObjectById(Memory.rooms[roomName].repairQueue[0]);\r\n            while (!id) {\r\n                Memory.rooms[roomName].repairQueue.shift();\r\n                id = Game.getObjectById(Memory.rooms[roomName].repairQueue[0]);\r\n            }\r\n        }\r\n\r\n        const needsRepair = _.find(Memory.rooms[roomName].repairQueue, (id: string) => {\r\n            const struct: RoomObject | null = _.isUndefined(id) ? null : Game.getObjectById(id);\r\n            return !_.isNull(struct) && (!own || struct.pos.roomName === creep.memory.operateInRoom);\r\n        });\r\n\r\n        if (_.isUndefined(needsRepair)) {\r\n            return null;\r\n        }\r\n\r\n        Memory.rooms[roomName].repairQueue = _.filter(Memory.rooms[roomName].repairQueue, (id) => id !== needsRepair);\r\n\r\n        return Game.getObjectById(needsRepair);\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * Checks if creep stans on road and if not initiates road building\r\n     *\r\n     * @param {Creep} creep\r\n     */\r\n    public tryBuildRoad(creep: Creep) {\r\n        if (Memory.autoBuildRoads) {\r\n            const road = _.filter(creep.room.lookAt(creep.pos), (obj: LookAtResult) => {\r\n\r\n                return obj && obj.structure &&\r\n                    ((obj.type === LOOK_STRUCTURES && obj.structure.structureType === STRUCTURE_ROAD) ||\r\n                        obj.type === LOOK_CONSTRUCTION_SITES);\r\n            });\r\n\r\n            if (!road.length) {\r\n                creep.room.createConstructionSite(creep.pos, STRUCTURE_ROAD);\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateInfrastructure() {\r\n        _.forOwn(Game.rooms, (room) => {\r\n            if (_.isUndefined(room.memory.repairQueue)) {\r\n                room.memory.repairQueue = [];\r\n            }\r\n            if (_.isUndefined(room.memory.spawnQueue)) {\r\n                room.memory.spawnQueue = [];\r\n            }\r\n            if (_.isUndefined(room.memory.creepCount)) {\r\n                room.memory.creepCount = {};\r\n            }\r\n        });\r\n\r\n        if (_.isUndefined(Memory.harvestedSources)) {\r\n            Memory.harvestedSources = {};\r\n        }\r\n        if (_.isUndefined(Memory.autoBuildRoads)) {\r\n            Memory.autoBuildRoads = true;\r\n        }\r\n        if (_.isUndefined(Memory.maxWallHits)) {\r\n            Memory.maxWallHits = 100000;\r\n        }\r\n        if (_.isUndefined(Memory.maxRampartHits)) {\r\n            Memory.maxRampartHits = 30000;\r\n        }\r\n    }\r\n}\r\n\r\nexport const utils = new Utils();\r\n","module.exports = require(\"lodash\");"],"sourceRoot":""}