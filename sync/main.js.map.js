module.exports = {"version":3,"sources":["webpack/bootstrap","external \"lodash\"","./src/utils.ts","./src/main.ts","./src/roles.ts","./src/limits.ts","./src/role.builder.ts","./src/role.carrier.ts","./src/role.claimer.ts","./src/role.harvester.ts","./src/role.upgrader.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","require","_","Messages","BUILD","CONSTRUCT_SYM","DISTRIBUTE","HARVEST","PICKUP","UPGRADE","Utils","buildPriority","creep","site","priority","structureType","STRUCTURE_SPAWN","STRUCTURE_EXTENSION","STRUCTURE_CONTAINER","STRUCTURE_LINK","STRUCTURE_TOWER","STRUCTURE_STORAGE","memory","operateInRoom","pos","roomName","clearMemory","forOwn","Memory","creeps","Game","target","harvestedSources","rooms","room","enqueueStructure","isUndefined","includes","repairQueue","id","push","findConstructionSite","sortBy","constructionSites","getEnergy","result","Resource","pickup","OK","energyTarget","Source","harvest","withdraw","RESOURCE_ENERGY","getEnergyStorageTarget","getObjectById","targets","find","FIND_DROPPED_RESOURCES","filter","res","resourceType","concat","FIND_MY_STRUCTURES","struct","store","energy","findClosestByPath","maxOps","FIND_SOURCES","moveTo","ERR_NOT_FOUND","noPathFinding","visualizePathStyle","stroke","reusePath","navigateToDesignatedRoom","shiftStructure","own","length","shift","needsRepair","isNull","tryBuildRoad","autoBuildRoads","lookAt","obj","structure","type","LOOK_STRUCTURES","STRUCTURE_ROAD","LOOK_CONSTRUCTION_SITES","createConstructionSite","updateInfrastructure","spawnQueue","creepCount","maxWallHits","maxRampartHits","utils","roles_1","utils_1","main","LoopFunctions","findDamagedStructures","FIND_STRUCTURES","STRUCTURE_WALL","hits","STRUCTURE_RAMPART","hitsMax","towerLogic","structures","tower_1","closestHostile","findClosestByRange","FIND_HOSTILE_CREEPS","inRangeTo","towerActive","attack","closestDamagedCreep","FIND_MY_CREEPS","heal","closestDamagedStructure","repair","damagedCreep","creepActions","rolesModule","run","loop","countCreeps","controller","getOwnPropertyNames","unshift","body","CARRY","MOVE","role","CARRIER","WORK","HARVESTER","spawn","spawns","processSpawnQueue","spawning","spawningCreep","visual","text","x","y","align","opacity","limits_1","role_builder_1","role_carrier_1","role_claimer_1","role_harvester_1","role_upgrader_1","BUILDER","CLAIMER","UPGRADER","roles","builder","roleBuilder","carrier","roleCarrier","claimer","roleClaimer","harvester","roleHarvester","upgrader","roleUpgrader","RolesModule","roleName","roomMem","forEach","spec","console","log","JSON","stringify","canCreateCreep","newName","createCreep","_this","this","energyAvailable","limit","flags","claim","reserve","limits","Builder","availEnergy","building","carry","say","carryCapacity","buildTarget","Structure","ERR_NOT_IN_RANGE","ConstructionSite","build","src","findInRange","RoomPosition","sites","Carrier","parts","Math","floor","Array","moveParts","ceil","hauling","getStoreTarget","transfer","getEnergyTarget","drops","drop","amount","conts","cont","controllerCont","storeCapacity","FIND_SOURCES_ACTIVE","energyCapacityAvailable","energyCapacity","ext","designatedRoom","towers","tower","Claimer","CLAIM","flag","sameRoom","claimTarget","structs","lookForAt","str","STRUCTURE_CONTROLLER","my","attackController","claimController","reserveController","Harvester","findSource","dst","Upgrader","upgrading","upgradeController"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"lodash\");","/*\r\n * Module code goes here. Use 'module.exports' to export things:\r\n * module.exports.thing = 'a thing';\r\n *\r\n * You can import it from another modules like this:\r\n * var mod = require('utils');\r\n * mod.thing == 'a thing'; // true\r\n */\r\n\r\nimport * as _ from \"lodash\";\r\n\r\nimport {limits} from \"./limits\";\r\n\r\nexport const Messages = {\r\n    BUILD: \"\\uD83D\\uDEA7 build\",\r\n    CONSTRUCT_SYM: \"\\uD83D\\uDEE0\",\r\n    DISTRIBUTE: \"\\u2194 distr\",\r\n    HARVEST: \"\\uD83D\\uDD04 harvest\",\r\n    PICKUP: \"\\u2B06 pickup\",\r\n    UPGRADE: \"\\u26A1 upgrade\"\r\n};\r\n\r\nexport class Utils {\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @param {ConstructionSite} site\r\n     * @return {number}\r\n     */\r\n    private static buildPriority(creep: Creep, site: ConstructionSite) {\r\n        let priority;\r\n        switch (site.structureType) {\r\n            case STRUCTURE_SPAWN:\r\n                priority = 1;\r\n                break;\r\n            case STRUCTURE_EXTENSION:\r\n                priority = 2;\r\n                break;\r\n            case STRUCTURE_CONTAINER:\r\n                priority = 3;\r\n                break;\r\n            case STRUCTURE_LINK:\r\n                priority = 4;\r\n                break;\r\n            case STRUCTURE_TOWER:\r\n                priority = 5;\r\n                break;\r\n            case STRUCTURE_STORAGE:\r\n                priority = 6;\r\n                break;\r\n            default:\r\n                priority = 7;\r\n                break;\r\n        }\r\n\r\n        return creep.memory.operateInRoom === site.pos.roomName ? priority : priority + 20;\r\n    }\r\n\r\n    public clearMemory() {\r\n        _.forOwn(Memory.creeps, (creep, name: string) => {\r\n            if (!Game.creeps.hasOwnProperty(name)) {\r\n                if (creep.target) {\r\n                    delete Memory.harvestedSources[creep.target];\r\n                }\r\n\r\n                delete Memory.creeps[name];\r\n            }\r\n        });\r\n\r\n        _.forOwn(Memory.rooms, (room, name: string) => {\r\n            if (!Game.rooms.hasOwnProperty(name)) {\r\n                delete Memory.rooms[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {Room} room\r\n     * @param {object} object\r\n     * @param {string} object.id\r\n     */\r\n    public enqueueStructure(room: Room, object: Structure) {\r\n        if (_.isUndefined(object)) {\r\n            return;\r\n        }\r\n\r\n        if (!_.includes(room.memory.repairQueue, object.id)) {\r\n            room.memory.repairQueue.push(object.id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @return {undefined|ConstructionSite}\r\n     */\r\n    public findConstructionSite(creep: Creep) {\r\n        return _.sortBy(Game.constructionSites, [(site: ConstructionSite) => {\r\n            return Utils.buildPriority(creep, site);\r\n        }])[0];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @param {Resource|Source|Structure} target\r\n     */\r\n    public getEnergy(creep: Creep, target: Resource | Source | Structure) {\r\n        let result;\r\n        if (target instanceof Resource) {\r\n            result = creep.pickup(target);\r\n            if (result === OK) {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        } else if (target instanceof Source) {\r\n            result = creep.harvest(target);\r\n        } else {\r\n            result = creep.withdraw(target, RESOURCE_ENERGY);\r\n            if (result === OK) {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {RoomObject}\r\n     */\r\n    public getEnergyStorageTarget(creep: Creep) {\r\n        let target: Structure | Resource | Source | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (!target) {\r\n            let targets: RoomObject[] = creep.room.find(FIND_DROPPED_RESOURCES, {\r\n                filter: (res: Resource) => {\r\n                    return res.resourceType === RESOURCE_ENERGY;\r\n                }\r\n            });\r\n\r\n            targets = targets.concat(creep.room.find(FIND_MY_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    switch (struct.structureType) {\r\n                        case STRUCTURE_STORAGE:\r\n                            const storage = struct as StructureStorage;\r\n                            return 0 < storage.store[RESOURCE_ENERGY];\r\n                        case STRUCTURE_CONTAINER:\r\n                            const container = struct as StructureContainer;\r\n                            return 0 < container.store[RESOURCE_ENERGY];\r\n                        case STRUCTURE_LINK:\r\n                            const link = struct as StructureLink;\r\n                            return 0 < link.energy;\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n            }));\r\n\r\n            target = creep.pos.findClosestByPath(targets, {\r\n                maxOps: 1000\r\n            }) as Structure;\r\n        }\r\n\r\n        if (!target) {\r\n            target = creep.pos.findClosestByPath(FIND_SOURCES);\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @param {RoomPosition} target\r\n     */\r\n    public moveTo(creep: Creep, target: RoomPosition) {\r\n        if (ERR_NOT_FOUND === creep.moveTo(target, {\r\n                noPathFinding: true,\r\n                visualizePathStyle: {stroke: \"#ffffff\"}\r\n            })) {\r\n            creep.moveTo(target, {\r\n                reusePath: 20,\r\n                visualizePathStyle: {stroke: \"#ffffff\"}\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Creep} creep\r\n     */\r\n    public navigateToDesignatedRoom(creep: Creep) {\r\n        return creep.memory.operateInRoom !== creep.pos.roomName;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @param {boolean} own\r\n     * @return {null|RoomObject}\r\n     */\r\n    public shiftStructure(creep: Creep, own: boolean): Structure | null {\r\n        const roomName = creep.memory.operateInRoom;\r\n        if (0 < Memory.rooms[roomName].repairQueue.length) {\r\n            let id = Game.getObjectById(Memory.rooms[roomName].repairQueue[0]);\r\n            while (!id) {\r\n                Memory.rooms[roomName].repairQueue.shift();\r\n                id = Game.getObjectById(Memory.rooms[roomName].repairQueue[0]);\r\n            }\r\n        }\r\n\r\n        const needsRepair = _.find(Memory.rooms[roomName].repairQueue, (id: string) => {\r\n            const struct: RoomObject | null = _.isUndefined(id) ? null : Game.getObjectById(id);\r\n            return !_.isNull(struct) && (!own || struct.pos.roomName === creep.memory.operateInRoom);\r\n        });\r\n\r\n        if (_.isUndefined(needsRepair)) {\r\n            return null;\r\n        }\r\n\r\n        Memory.rooms[roomName].repairQueue = _.filter(Memory.rooms[roomName].repairQueue, (id) => id !== needsRepair);\r\n\r\n        return Game.getObjectById(needsRepair);\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * Checks if creep stans on road and if not initiates road building\r\n     *\r\n     * @param {Creep} creep\r\n     */\r\n    public tryBuildRoad(creep: Creep) {\r\n        if (Memory.autoBuildRoads) {\r\n            const road = _.filter(creep.room.lookAt(creep.pos), (obj: LookAtResult) => {\r\n\r\n                return obj && obj.structure &&\r\n                    ((obj.type === LOOK_STRUCTURES && obj.structure.structureType === STRUCTURE_ROAD) ||\r\n                        obj.type === LOOK_CONSTRUCTION_SITES);\r\n            });\r\n\r\n            if (!road.length) {\r\n                creep.room.createConstructionSite(creep.pos, STRUCTURE_ROAD);\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateInfrastructure() {\r\n        _.forOwn(Game.rooms, (room) => {\r\n            if (_.isUndefined(room.memory.repairQueue)) {\r\n                room.memory.repairQueue = [];\r\n            }\r\n            if (_.isUndefined(room.memory.spawnQueue)) {\r\n                room.memory.spawnQueue = [];\r\n            }\r\n            if (_.isUndefined(room.memory.creepCount)) {\r\n                room.memory.creepCount = {};\r\n            }\r\n        });\r\n\r\n        if (_.isUndefined(Memory.harvestedSources)) {\r\n            Memory.harvestedSources = {};\r\n        }\r\n        if (_.isUndefined(Memory.autoBuildRoads)) {\r\n            Memory.autoBuildRoads = true;\r\n        }\r\n        if (_.isUndefined(Memory.maxWallHits)) {\r\n            Memory.maxWallHits = 100000;\r\n        }\r\n        if (_.isUndefined(Memory.maxRampartHits)) {\r\n            Memory.maxRampartHits = 30000;\r\n        }\r\n    }\r\n}\r\n\r\nexport const utils = new Utils();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {CARRIER, HARVESTER, rolesModule as roles} from \"./roles\";\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nclass LoopFunctions {\r\n    public findDamagedStructures() {\r\n        _.forOwn(Game.rooms, (room) => {\r\n            room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if ((struct.structureType === STRUCTURE_WALL && struct.hits < Memory.maxWallHits) ||\r\n                        (struct.structureType === STRUCTURE_RAMPART && struct.hits < Memory.maxRampartHits / 2) ||\r\n                        (struct.structureType === STRUCTURE_CONTAINER && struct.hits < struct.hitsMax - 50000) ||\r\n                        (struct.structureType !== STRUCTURE_RAMPART && struct.structureType !== STRUCTURE_WALL &&\r\n                            struct.hits < struct.hitsMax / 2)) { utils.enqueueStructure(room, struct); }\r\n                    return false;\r\n                }}); });\r\n    }\r\n\r\n    public towerLogic() {\r\n        _.forOwn(Game.structures, (struct: Structure) => {\r\n            if (struct.structureType === STRUCTURE_TOWER) {\r\n                const tower = struct as StructureTower;\r\n                const closestHostile: Creep | null = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.pos.inRangeTo(tower.pos, tower.room.memory.towerActive ? 15 : 7);\r\n                    }\r\n                });\r\n                if (closestHostile) {\r\n                    tower.room.memory.towerActive = true;\r\n                    tower.attack(closestHostile);\r\n                } else {\r\n                    tower.room.memory.towerActive = false;\r\n                }\r\n\r\n                const closestDamagedCreep: Creep | null = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.hits < creep.hitsMax / 3;\r\n                    }\r\n                });\r\n                if (closestDamagedCreep) {\r\n                    tower.heal(closestDamagedCreep);\r\n                }\r\n\r\n                if (700 < tower.energy) {\r\n                    const closestDamagedStructure: Structure | null = tower.pos.findClosestByRange(FIND_STRUCTURES, {\r\n                        filter: (structure: Structure) => {\r\n                            return (structure.structureType === STRUCTURE_RAMPART &&\r\n                                    structure.hits < Memory.maxRampartHits)\r\n                                || (structure.structureType !== STRUCTURE_WALL &&\r\n                                    structure.structureType !== STRUCTURE_RAMPART &&\r\n                                    structure.hits < structure.hitsMax / 3);\r\n                        }\r\n                    });\r\n                    if (closestDamagedStructure) {\r\n                        tower.repair(closestDamagedStructure);\r\n                    }\r\n                }\r\n\r\n                // if nothing to do heal damaged creeps\r\n                const damagedCreep: Creep | null = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.hits < creep.hitsMax;\r\n                    }\r\n                });\r\n                if (damagedCreep) {\r\n                    tower.heal(damagedCreep);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public creepActions() {\r\n        _.forOwn(Game.creeps, (creep) => {\r\n            roles.run(creep);\r\n        });\r\n    }\r\n}\r\n\r\nconst main = new LoopFunctions();\r\n\r\nmodule.exports.loop = () => {\r\n    utils.updateInfrastructure();\r\n\r\n    utils.clearMemory();\r\n\r\n    main.findDamagedStructures();\r\n\r\n    roles.countCreeps();\r\n\r\n    _.forOwn(Game.rooms, (room) => {\r\n        if (room.controller) {\r\n\r\n            if (Object.getOwnPropertyNames(Game.creeps).length === 0) {\r\n                room.memory.spawnQueue = [];\r\n                room.memory.spawnQueue.unshift({\r\n                    body: [CARRY, MOVE],\r\n                    role: CARRIER\r\n                });\r\n                room.memory.spawnQueue.unshift({\r\n                    body: [CARRY, WORK, WORK, MOVE],\r\n                    role: HARVESTER\r\n                });\r\n            }\r\n\r\n            roles.spawn(room);\r\n        }\r\n    });\r\n\r\n    _.forOwn(Game.spawns, (spawn) => {\r\n        roles.processSpawnQueue(spawn);\r\n\r\n        if (spawn.spawning) {\r\n            const spawningCreep = Game.creeps[spawn.spawning.name];\r\n            spawn.room.visual.text(\r\n                Messages.CONSTRUCT_SYM + \" \" + spawningCreep.memory.role,\r\n                spawn.pos.x + 1,\r\n                spawn.pos.y,\r\n                {align: \"left\", opacity: 0.8});\r\n        }\r\n    });\r\n\r\n    main.towerLogic();\r\n\r\n    main.creepActions();\r\n};\r\n","import * as _ from \"lodash\";\r\n\r\nimport {limits} from \"./limits\";\r\nimport {Role} from \"./Role\";\r\n\r\nimport {roleBuilder} from \"./role.builder\";\r\nimport {roleCarrier} from \"./role.carrier\";\r\nimport {roleClaimer} from \"./role.claimer\";\r\nimport {roleHarvester} from \"./role.harvester\";\r\nimport {roleUpgrader} from \"./role.upgrader\";\r\n\r\nexport interface Roles extends _.Dictionary<Role> {\r\n    builder: Role;\r\n    carrier: Role;\r\n    claimer: Role;\r\n    harvester: Role;\r\n    upgrader: Role;\r\n}\r\n\r\nexport type CreepRole = keyof Roles;\r\n\r\nexport const BUILDER: CreepRole = \"builder\";\r\nexport const CARRIER: CreepRole = \"carrier\";\r\nexport const CLAIMER: CreepRole = \"claimer\";\r\nexport const HARVESTER: CreepRole = \"harvester\";\r\nexport const UPGRADER: CreepRole = \"upgrader\";\r\n\r\nexport const roles: Roles = {\r\n    builder:   roleBuilder,\r\n    carrier:   roleCarrier,\r\n    claimer:   roleClaimer,\r\n    harvester: roleHarvester,\r\n    upgrader:  roleUpgrader\r\n};\r\n\r\nexport interface BodySpec {\r\n    body: BodyPartConstant[];\r\n    role: CreepRole;\r\n}\r\n\r\nexport class RolesModule {\r\n    public countCreeps() {\r\n        _.forOwn(roles, (role, roleName: string) => {\r\n            _.forOwn(Memory.rooms, (roomMem) => {\r\n                roomMem.creepCount[roleName] = 0;\r\n            });\r\n        });\r\n\r\n        _.forOwn(Game.creeps, (creep) => {\r\n            if (!creep.memory.operateInRoom) {\r\n                Memory.rooms[creep.room.name].creepCount[creep.memory.role] += 1;\r\n            } else {\r\n                Memory.rooms[creep.memory.operateInRoom].creepCount[creep.memory.role] += 1;\r\n            }\r\n        });\r\n\r\n        _.forOwn(Memory.rooms, (roomMem) => {\r\n            _.forEach(roomMem.spawnQueue, (spec) => {\r\n                roomMem.creepCount[spec.role] += 1;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  @type {function}\r\n     *\r\n     *  @param {StructureSpawn} spawn Spawn on which start spawning\r\n     */\r\n    public processSpawnQueue(spawn: StructureSpawn) {\r\n        if (spawn.spawning) {\r\n            return;\r\n        }\r\n\r\n        const room = spawn.room;\r\n        const spec = room.memory.spawnQueue.shift();\r\n        if (spec) {\r\n            console.log(\"Processing spawn Q \" + spawn.name + \" \"\r\n                + JSON.stringify({room: room.name, role: spec.role}));\r\n\r\n            if (spawn.canCreateCreep(spec.body) === OK) {\r\n                const newName = spawn.createCreep(spec.body, undefined, {operateInRoom: room.name, role: spec.role});\r\n                console.log(\"Spawning new \" + spec.role + \": \" + newName);\r\n            } else if (\"claimer\" === spec.role) {\r\n                room.memory.spawnQueue.push(spec);\r\n            } else {\r\n                room.memory.spawnQueue.unshift(spec);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Creep} creep\r\n     */\r\n    public run(creep: Creep) {\r\n        roles[creep.memory.role].run(creep);\r\n    }\r\n\r\n    /**\r\n     *  @type {function}\r\n     *\r\n     *  @param {Room} room\r\n     *  @param {string|object} [role] Role of the new creep\r\n     *  @param {Array<string>} role.body Body of spawning creep\r\n     *  @param {string} role.role Role of spawning creep\r\n     */\r\n    public spawn(room: Room, role?: CreepRole | BodySpec) {\r\n        if (!role) {\r\n            _.forOwn(roles, (r, name: CreepRole) => {\r\n                if (name && room.memory.creepCount[name] < this.limit(name)) {\r\n                    const energy = room.energyAvailable;\r\n\r\n                    const body = r.body(energy);\r\n                    room.memory.spawnQueue.push({ body, role: name });\r\n                }\r\n            });\r\n        } else if (typeof role === \"string\") {\r\n            const energy = room.energyAvailable;\r\n\r\n            const body = roles[role].body(energy);\r\n            room.memory.spawnQueue.push({ body, role });\r\n        } else {\r\n            room.memory.spawnQueue.push(role as BodySpec);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} role\r\n     * @returns {number}\r\n     */\r\n    private limit(role: CreepRole): number {\r\n        if (role === \"claimer\") {\r\n            return _.isUndefined(Game.flags[\"claim\"]) && _.isUndefined(Game.flags[\"reserve\"])  ? 0 : limits[role];\r\n        } else {\r\n            return limits[role];\r\n        }\r\n    }\r\n}\r\n\r\nexport const rolesModule = new RolesModule();\r\n","import {Dictionary} from \"lodash\";\r\n\r\nexport const limits: Dictionary<number> = {\r\n    builder:   2,\r\n    carrier:   3,\r\n    claimer:   2,\r\n    harvester: 2,\r\n    upgrader:  2\r\n};\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Builder implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, CARRY, CARRY, MOVE]; // 250\r\n        } else if (availEnergy < 450) {\r\n            return [WORK, CARRY, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 550) {\r\n            return [WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE]; // 450\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE]; // 550\r\n        } else if (availEnergy < 650) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else if (availEnergy < 750) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE]; // 650\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE]; // 750\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (!creep.memory.building && !creep.memory.energyTarget && utils.navigateToDesignatedRoom(creep)\r\n            && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n            return;\r\n        }\r\n\r\n        if (creep.memory.building && creep.carry.energy === 0) {\r\n            creep.memory.building = false;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.HARVEST);\r\n        }\r\n\r\n        if (!creep.memory.building && creep.carry.energy === creep.carryCapacity) {\r\n            creep.memory.building = true;\r\n            creep.say(Messages.BUILD);\r\n        }\r\n\r\n        if (creep.memory.building) {\r\n            let target = Game.getObjectById(creep.memory.buildTarget) as Structure | ConstructionSite | null;\r\n            if (!target) {\r\n                target = utils.shiftStructure(creep, true);\r\n\r\n                if (!target) {\r\n                    target = utils.findConstructionSite(creep);\r\n                }\r\n\r\n                if (!target) {\r\n                    target = utils.shiftStructure(creep, false);\r\n                }\r\n\r\n                if (target) {\r\n                    creep.memory.buildTarget = target.id;\r\n                } else {\r\n                    creep.say(\"\\uD83D\\uDEA7 nothing\");\r\n                    creep.memory.buildTarget = \"\";\r\n                    creep.memory.energyTarget = \"\";\r\n                    creep.memory.building = false;\r\n                }\r\n            }\r\n\r\n            if (target instanceof Structure) {\r\n                if ((target.structureType !== STRUCTURE_WALL &&\r\n                        target.structureType !== STRUCTURE_RAMPART && target.hits < target.hitsMax) ||\r\n                    (target.structureType === STRUCTURE_WALL && target.hits < Memory.maxWallHits) ||\r\n                    (target.structureType === STRUCTURE_RAMPART && target.hits < Memory.maxRampartHits)) {\r\n                    if (creep.repair(target) === ERR_NOT_IN_RANGE) {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                } else {\r\n                    creep.memory.buildTarget = \"\";\r\n                    creep.memory.building = false;\r\n                }\r\n            } else if (target instanceof ConstructionSite) {\r\n                if (creep.build(target) === ERR_NOT_IN_RANGE) {\r\n                    utils.moveTo(creep, target.pos);\r\n                }\r\n            } else {\r\n                creep.memory.buildTarget = \"\";\r\n                creep.memory.building = false;\r\n            }\r\n        } else {\r\n            if (creep.carry.energy < creep.carryCapacity) {\r\n                const target = utils.getEnergyStorageTarget(creep);\r\n                if (target) {\r\n                    const src = creep.pos.findInRange([target], 1);\r\n                    if (src.length) {\r\n                        utils.getEnergy(creep, src[0]);\r\n                    } else {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                } else {\r\n                    creep.say(\"No energy\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {Creep} creep\r\n     * @returns {ConstructionSite}\r\n     */\r\n    private findConstructionSite(type: StructureConstant, creep: Creep) {\r\n        let target = null;\r\n\r\n        const sites = _.filter(Game.constructionSites, (site: ConstructionSite) => {\r\n            return  site.structureType === type && site.pos.roomName === creep.memory.operateInRoom;\r\n        });\r\n\r\n        if (sites.length) {\r\n            target = creep.pos.findClosestByPath(sites);\r\n            if (!target) {\r\n                target = sites[0];\r\n            }\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n}\r\n\r\nexport const roleBuilder: Role = new Builder();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\n/**\r\n *\r\n * @class\r\n * @extends {Role}\r\n */\r\nclass Carrier implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        let parts;\r\n        if (availEnergy < 300) {\r\n            parts = 6;\r\n        } else if (750 < availEnergy) {\r\n            parts = 15;\r\n        } else {\r\n            parts = Math.floor(availEnergy / 50);\r\n        }\r\n\r\n        const body = new Array(parts);\r\n        const moveParts = Math.ceil(parts / 3);\r\n\r\n        for (let i = 0; i < parts; ++i) {\r\n            body[i] = i < moveParts ? MOVE : CARRY;\r\n        }\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (!creep.memory.hauling && !creep.memory.energyTarget && utils.navigateToDesignatedRoom(creep)\r\n             && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n            return;\r\n        }\r\n\r\n        if (creep.memory.hauling && creep.carry.energy === 0) {\r\n            creep.memory.hauling = false;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.PICKUP);\r\n        }\r\n\r\n        if (!creep.memory.hauling && creep.carry.energy === creep.carryCapacity) {\r\n            creep.memory.hauling = true;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.DISTRIBUTE);\r\n        }\r\n\r\n        if (creep.memory.hauling) {\r\n            const target = this.getStoreTarget(creep);\r\n            if (target && creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            } else {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        } else {\r\n            const target = this.getEnergyTarget(creep);\r\n            if (target && utils.getEnergy(creep, target) === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            } else {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {Resource|Source|Structure}\r\n     */\r\n    private getEnergyTarget(creep: Creep): Resource | Source | Structure | null {\r\n        let target: Structure | Resource | Source | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (target instanceof Source && creep.pos.inRangeTo(target.pos, 2)) {\r\n            target = null;\r\n        }\r\n\r\n        if (!target) {\r\n            // dropped energy\r\n            const drops: Resource[] = creep.room.find(FIND_DROPPED_RESOURCES, {\r\n                filter: (drop: Resource) => {\r\n                    return drop.resourceType === RESOURCE_ENERGY && 50 < drop.amount;\r\n                }\r\n            });\r\n\r\n            target = _.sortBy(drops, (drop: Resource) => {\r\n                return -drop.amount;\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            // containers near sources\r\n            const conts: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_CONTAINER) {\r\n                        const cont = struct as StructureContainer;\r\n                        return cont.id !== creep.room.memory.controllerCont && 20 < cont.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n\r\n            // most full container\r\n            target = _.sortBy(conts, (cont) => {\r\n                if (cont.structureType === STRUCTURE_CONTAINER) {\r\n                    const c = cont as StructureContainer;\r\n                    return c.storeCapacity - c.store.energy;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            const targets: Structure[] = creep.room.find(FIND_MY_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_STORAGE) {\r\n                        const store = struct as StructureStorage;\r\n                        return store.structureType === STRUCTURE_STORAGE && 0 < store.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n\r\n                }\r\n            });\r\n            target = targets[0];\r\n        }\r\n\r\n        if (!target) {\r\n            target = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE, {\r\n                maxOps: 100\r\n            });\r\n            if (!target) {\r\n                const targets: Source[] = creep.room.find(FIND_SOURCES);\r\n                target = targets[0];\r\n            }\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {Spawn|Structure}\r\n     */\r\n    private getStoreTarget(creep: Creep): Creep | Structure | null {\r\n        let target: Creep | Structure | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for spawns and extensions');\r\n            if (creep.room.energyAvailable < creep.room.energyCapacityAvailable) {\r\n                target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\r\n                    filter: (s: Structure) => {\r\n                        switch (s.structureType) {\r\n                            case STRUCTURE_SPAWN:\r\n                                const spawn = s as StructureExtension;\r\n                                return spawn.energy < spawn.energyCapacity\r\n                                    && creep.memory.operateInRoom === spawn.pos.roomName;\r\n                            case STRUCTURE_EXTENSION:\r\n                                const ext = s as StructureExtension;\r\n                                return ext.energy < ext.energyCapacity\r\n                                    && creep.memory.operateInRoom === ext.pos.roomName;\r\n                                default:\r\n                                return false;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n            // console.log('Harvester ' + creep.name + ' harvesting target: ' + target.id);\r\n\r\n        if (!target) {\r\n            // containers near controllers\r\n            // console.log('Carrier ' + creep.name + ' looking for controller container');\r\n\r\n            const designatedRoom = Game.rooms[creep.memory.operateInRoom];\r\n\r\n            const cont: StructureContainer | null =\r\n                !_.isNull(designatedRoom) ? Game.getObjectById(designatedRoom.memory.controllerCont) : null;\r\n            if (cont && 500 < cont.storeCapacity - cont.store.energy) {\r\n                target = cont;\r\n            }\r\n        }\r\n\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for towers');\r\n            const towers: Structure[] = _.filter(Game.structures, (struct: Structure) => {\r\n                if (STRUCTURE_TOWER === struct.structureType) {\r\n                    const tower = struct as StructureTower;\r\n                    return tower.room.name === creep.memory.operateInRoom &&\r\n                    0 <= tower.energyCapacity - tower.energy - 300;\r\n                } else {\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            // emptiest tower\r\n            target = _.sortBy(towers, (struct) => {\r\n                if (struct.structureType === STRUCTURE_CONTAINER) {\r\n                    const tower = struct as StructureTower;\r\n                    return tower.energyCapacity + tower.energy;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            // looking for storage\r\n            // console.log('Carrier ' + creep.name + ' looking for storage');\r\n            const storages: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_STORAGE) {\r\n                        const store = struct as StructureStorage;\r\n                        return 0 < store.storeCapacity - store.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n            target = storages[0];\r\n        }\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for sources');\r\n\r\n            const targets: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    switch (struct.structureType) {\r\n                        case STRUCTURE_EXTENSION:\r\n                            const ext = struct as StructureExtension;\r\n                            return ext.energy < ext.energyCapacity && creep.memory.operateInRoom === ext.pos.roomName;\r\n                        case STRUCTURE_SPAWN:\r\n                            const spawn = struct as StructureSpawn;\r\n                            return spawn.energy < spawn.energyCapacity\r\n                                && creep.memory.operateInRoom === spawn.pos.roomName;\r\n                        default:\r\n                            return false;\r\n                    }\r\n\r\n                }\r\n            });\r\n            target = targets[0];\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n}\r\n\r\nexport const roleCarrier: Role = new Carrier();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\n/**\r\n *\r\n * @class\r\n * @extends {Role}\r\n */\r\nclass Claimer implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 1400) {\r\n            return [MOVE, MOVE, CLAIM];\r\n        } else if (availEnergy < 2100) {\r\n            return [MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM];\r\n        } else if (availEnergy < 2800) {\r\n            return [MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM, CLAIM];\r\n        } else {\r\n            return [MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM, CLAIM, CLAIM];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        let flag = Game.flags[\"claim\"];\r\n        if (!flag) {\r\n            flag = Game.flags[\"reserve\"];\r\n        }\r\n\r\n        const sameRoom = flag && creep.room.name === flag.pos.roomName;\r\n\r\n        if (!flag) {\r\n            delete(creep.memory.claimTarget);\r\n        }\r\n\r\n        if (flag && !sameRoom) {\r\n            utils.moveTo(creep, flag.pos);\r\n        }\r\n\r\n        if (flag && sameRoom) {\r\n            const structs = creep.room.lookForAt(LOOK_STRUCTURES, flag.pos);\r\n            if (structs.length) {\r\n                _.forEach(structs, (str: Structure) => {\r\n                    if (str.structureType === STRUCTURE_CONTROLLER) {\r\n                        creep.memory.claimTarget = str.id;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (creep.memory.claimTarget) {\r\n            // Move to target & claim\r\n            const controller: StructureController | null = Game.getObjectById(creep.memory.claimTarget);\r\n            if (controller) {\r\n                if (flag.name === \"claim\") {\r\n                    if (creep.room.controller && !creep.room.controller.my) {\r\n                        if (creep.attackController(creep.room.controller) === ERR_NOT_IN_RANGE) {\r\n                            creep.moveTo(creep.room.controller);\r\n                        }\r\n                    } else {\r\n                        if (creep.claimController(controller) !== OK) {\r\n                            utils.moveTo(creep, controller.pos);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (creep.reserveController(controller) !== OK) {\r\n                        utils.moveTo(creep, controller.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const roleClaimer: Role = new Claimer();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Harvester implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, WORK, CARRY, MOVE]; // 300\r\n        } else if (availEnergy < 400) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 500) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 400\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 500\r\n        } else if (availEnergy < 700) {\r\n            return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 700\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        let target: Source | null = Game.getObjectById(creep.memory.target);\r\n\r\n        if (!target) {\r\n\r\n            target = this.findSource(creep);\r\n\r\n            if (target) {\r\n\r\n                if (target.room.name !== creep.room.name) {\r\n                    console.log(\"Harvester found target in other room: \" + target.room);\r\n                }\r\n\r\n                Memory.harvestedSources[target.id] = target.id;\r\n                creep.memory.target = target.id;\r\n                creep.say(Messages.HARVEST);\r\n            }\r\n        }\r\n\r\n        if (0 < creep.carry.energy) {\r\n            // console.log('Harvester ' + creep.name + ' unloading');// JSON.stringify(target, null, 4));\r\n            const dst: Structure[] = creep.pos.findInRange(FIND_STRUCTURES, 1, {\r\n                filter: (struct: StructureLink | StructureContainer) => {\r\n                    return (struct.structureType === STRUCTURE_LINK && struct.energy < struct.energyCapacity) ||\r\n                        (struct.structureType === STRUCTURE_CONTAINER && struct.store.energy < struct.storeCapacity);\r\n                }\r\n            });\r\n\r\n            if (dst.length) {\r\n                creep.transfer(dst[0], RESOURCE_ENERGY);\r\n            } else {\r\n                creep.drop(RESOURCE_ENERGY);\r\n            }\r\n        }\r\n        // console.log('Harvester ' + creep.name + ' harvesting target: ' + target.id);\r\n        // JSON.stringify(target, null, 4));\r\n        if (target) {\r\n            const err = creep.harvest(target);\r\n            if (err === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private findSource(creep: Creep): Source | null {\r\n        const sources: Source[] = creep.room.find(FIND_SOURCES, {\r\n            filter: (src: Source) => {\r\n                return !Memory.harvestedSources.hasOwnProperty(src.id);\r\n            }\r\n        });\r\n\r\n        return sources[0];\r\n    }\r\n}\r\n\r\nexport const roleHarvester: Role = new Harvester();\r\n","import {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Upgrader implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, CARRY, MOVE, MOVE]; // 250\r\n        } else if (availEnergy < 400) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 500) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 400\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 500\r\n        } else if (availEnergy < 700) {\r\n            return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 700\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (utils.navigateToDesignatedRoom(creep) && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n        } else {\r\n            if (creep.memory.upgrading && creep.carry.energy === 0) {\r\n                creep.memory.upgrading = false;\r\n                creep.say(Messages.HARVEST);\r\n            }\r\n            if (!creep.memory.upgrading && creep.carry.energy === creep.carryCapacity) {\r\n                creep.memory.upgrading = true;\r\n                creep.memory.energyTarget = \"\";\r\n                creep.say(Messages.UPGRADE);\r\n            }\r\n\r\n            if (creep.memory.upgrading && creep.room.controller) {\r\n                if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {\r\n                    utils.moveTo(creep, creep.room.controller.pos);\r\n                }\r\n            } else {\r\n                const target = utils.getEnergyStorageTarget(creep);\r\n                if (target) {\r\n                    const src = creep.pos.findInRange([target], 1);\r\n                    if (src.length) {\r\n                        utils.getEnergy(creep, src[0]);\r\n                    } else {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const roleUpgrader: Role = new Upgrader();\r\n"],"sourceRoot":""}