module.exports = {"version":3,"sources":["webpack/bootstrap","external \"lodash\"","./src/utils.ts","./src/main.ts","./src/roles.ts","./src/limits.ts","./src/role.builder.ts","./src/role.carrier.ts","./src/role.claimer.ts","./src/role.harvester.ts","./src/role.upgrader.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","_","Messages","BUILD","CONSTRUCT_SYM","DISTRIBUTE","HARVEST","PICKUP","UPGRADE","Utils","buildPriority","creep","site","priority","structureType","STRUCTURE_SPAWN","STRUCTURE_EXTENSION","STRUCTURE_CONTAINER","STRUCTURE_LINK","STRUCTURE_TOWER","STRUCTURE_STORAGE","memory","operateInRoom","pos","roomName","clearMemory","forOwn","Memory","creeps","Game","target","harvestedSources","rooms","room","enqueueStructure","isUndefined","includes","repairQueue","id","push","findConstructionSite","sortBy","constructionSites","getEnergy","result","Resource","pickup","OK","energyTarget","Source","harvest","withdraw","RESOURCE_ENERGY","getEnergyStorageTarget","getObjectById","targets","find","FIND_DROPPED_RESOURCES","filter","res","resourceType","concat","FIND_MY_STRUCTURES","struct","store","energy","findClosestByPath","maxOps","FIND_SOURCES","moveTo","ERR_NOT_FOUND","noPathFinding","visualizePathStyle","stroke","reusePath","navigateToDesignatedRoom","shiftStructure","own","length","shift","needsRepair","isNull","tryBuildRoad","autoBuildRoads","lookAt","obj","structure","type","LOOK_STRUCTURES","STRUCTURE_ROAD","LOOK_CONSTRUCTION_SITES","createConstructionSite","updateInfrastructure","spawnQueue","creepCount","maxWallHits","maxRampartHits","utils","roles_1","utils_1","main","LoopFunctions","findDamagedStructures","FIND_STRUCTURES","STRUCTURE_WALL","hits","STRUCTURE_RAMPART","hitsMax","towerLogic","structures","tower_1","closestHostile","findClosestByRange","FIND_HOSTILE_CREEPS","inRangeTo","towerActive","attack","closestDamagedCreep","FIND_MY_CREEPS","heal","closestDamagedStructure","repair","damagedCreep","creepActions","rolesModule","run","loop","countCreeps","controller","getOwnPropertyNames","unshift","body","CARRY","MOVE","role","CARRIER","WORK","HARVESTER","spawn","spawns","processSpawnQueue","spawning","spawningCreep","visual","text","x","y","align","opacity","limits_1","role_builder_1","role_carrier_1","role_claimer_1","role_harvester_1","role_upgrader_1","BUILDER","CLAIMER","UPGRADER","roles","builder","roleBuilder","carrier","roleCarrier","claimer","roleClaimer","harvester","roleHarvester","upgrader","roleUpgrader","RolesModule","roleName","roomMem","forEach","spec","console","log","JSON","stringify","canCreateCreep","newName","createCreep","undefined","_this","this","energyAvailable","limit","flags","limits","Builder","availEnergy","building","carry","say","carryCapacity","buildTarget","Structure","ERR_NOT_IN_RANGE","ConstructionSite","build","src","findInRange","RoomPosition","sites","Carrier","parts","Math","floor","Array","moveParts","ceil","hauling","getStoreTarget","transfer","getEnergyTarget","drops","drop","amount","conts","cont","controllerCont","storeCapacity","FIND_SOURCES_ACTIVE","energyCapacityAvailable","energyCapacity","ext","designatedRoom","towers","tower","Claimer","CLAIM","flag","sameRoom","structs","lookForAt","str","STRUCTURE_CONTROLLER","claimTarget","my","attackController","claimController","reserveController","Harvester","findSource","dst","Upgrader","upgrading","upgradeController"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"lodash\");","/*\r\n * Module code goes here. Use 'module.exports' to export things:\r\n * module.exports.thing = 'a thing';\r\n *\r\n * You can import it from another modules like this:\r\n * var mod = require('utils');\r\n * mod.thing == 'a thing'; // true\r\n */\r\n\r\nimport * as _ from \"lodash\";\r\n\r\nimport {limits} from \"./limits\";\r\n\r\nexport const Messages = {\r\n    BUILD: \"\\uD83D\\uDEA7 build\",\r\n    CONSTRUCT_SYM: \"\\uD83D\\uDEE0\",\r\n    DISTRIBUTE: \"\\u2194 distr\",\r\n    HARVEST: \"\\uD83D\\uDD04 harvest\",\r\n    PICKUP: \"\\u2B06 pickup\",\r\n    UPGRADE: \"\\u26A1 upgrade\"\r\n};\r\n\r\nexport class Utils {\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @param {ConstructionSite} site\r\n     * @return {number}\r\n     */\r\n    private static buildPriority(creep: Creep, site: ConstructionSite) {\r\n        let priority;\r\n        switch (site.structureType) {\r\n            case STRUCTURE_SPAWN:\r\n                priority = 1;\r\n                break;\r\n            case STRUCTURE_EXTENSION:\r\n                priority = 2;\r\n                break;\r\n            case STRUCTURE_CONTAINER:\r\n                priority = 3;\r\n                break;\r\n            case STRUCTURE_LINK:\r\n                priority = 4;\r\n                break;\r\n            case STRUCTURE_TOWER:\r\n                priority = 5;\r\n                break;\r\n            case STRUCTURE_STORAGE:\r\n                priority = 6;\r\n                break;\r\n            default:\r\n                priority = 7;\r\n                break;\r\n        }\r\n\r\n        return creep.memory.operateInRoom === site.pos.roomName ? priority : priority + 20;\r\n    }\r\n\r\n    public clearMemory() {\r\n        _.forOwn(Memory.creeps, (creep, name: string) => {\r\n            if (!Game.creeps.hasOwnProperty(name)) {\r\n                if (creep.target) {\r\n                    delete Memory.harvestedSources[creep.target];\r\n                }\r\n\r\n                delete Memory.creeps[name];\r\n            }\r\n        });\r\n\r\n        _.forOwn(Memory.rooms, (room, name: string) => {\r\n            if (!Game.rooms.hasOwnProperty(name)) {\r\n                delete Memory.rooms[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {Room} room\r\n     * @param {object} object\r\n     * @param {string} object.id\r\n     */\r\n    public enqueueStructure(room: Room, object: Structure) {\r\n        if (_.isUndefined(object)) {\r\n            return;\r\n        }\r\n\r\n        if (!_.includes(room.memory.repairQueue, object.id)) {\r\n            room.memory.repairQueue.push(object.id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @return {undefined|ConstructionSite}\r\n     */\r\n    public findConstructionSite(creep: Creep) {\r\n        return _.sortBy(Game.constructionSites, [(site: ConstructionSite) => {\r\n            return Utils.buildPriority(creep, site);\r\n        }])[0];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @param {Resource|Source|Structure} target\r\n     */\r\n    public getEnergy(creep: Creep, target: Resource | Source | Structure) {\r\n        let result;\r\n        if (target instanceof Resource) {\r\n            result = creep.pickup(target);\r\n            if (result === OK) {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        } else if (target instanceof Source) {\r\n            result = creep.harvest(target);\r\n        } else {\r\n            result = creep.withdraw(target, RESOURCE_ENERGY);\r\n            if (result === OK) {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {RoomObject}\r\n     */\r\n    public getEnergyStorageTarget(creep: Creep) {\r\n        let target: Structure | Resource | Source | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (!target) {\r\n            let targets: RoomObject[] = creep.room.find(FIND_DROPPED_RESOURCES, {\r\n                filter: (res: Resource) => {\r\n                    return res.resourceType === RESOURCE_ENERGY;\r\n                }\r\n            });\r\n\r\n            targets = targets.concat(creep.room.find(FIND_MY_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    switch (struct.structureType) {\r\n                        case STRUCTURE_STORAGE:\r\n                            const storage = struct as StructureStorage;\r\n                            return 0 < storage.store[RESOURCE_ENERGY];\r\n                        case STRUCTURE_CONTAINER:\r\n                            const container = struct as StructureContainer;\r\n                            return 0 < container.store[RESOURCE_ENERGY];\r\n                        case STRUCTURE_LINK:\r\n                            const link = struct as StructureLink;\r\n                            return 0 < link.energy;\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n            }));\r\n\r\n            target = creep.pos.findClosestByPath(targets, {\r\n                maxOps: 1000\r\n            }) as Structure;\r\n        }\r\n\r\n        if (!target) {\r\n            target = creep.pos.findClosestByPath(FIND_SOURCES);\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @param {RoomPosition} target\r\n     */\r\n    public moveTo(creep: Creep, target: RoomPosition) {\r\n        if (ERR_NOT_FOUND === creep.moveTo(target, {\r\n                noPathFinding: true,\r\n                visualizePathStyle: {stroke: \"#ffffff\"}\r\n            })) {\r\n            creep.moveTo(target, {\r\n                reusePath: 20,\r\n                visualizePathStyle: {stroke: \"#ffffff\"}\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Creep} creep\r\n     */\r\n    public navigateToDesignatedRoom(creep: Creep) {\r\n        return creep.memory.operateInRoom !== creep.pos.roomName;\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * @param {Creep} creep\r\n     * @param {boolean} own\r\n     * @return {null|RoomObject}\r\n     */\r\n    public shiftStructure(creep: Creep, own: boolean): Structure | null {\r\n        const roomName = creep.memory.operateInRoom;\r\n        if (0 < Memory.rooms[roomName].repairQueue.length) {\r\n            let id = Game.getObjectById(Memory.rooms[roomName].repairQueue[0]);\r\n            while (!id) {\r\n                Memory.rooms[roomName].repairQueue.shift();\r\n                id = Game.getObjectById(Memory.rooms[roomName].repairQueue[0]);\r\n            }\r\n        }\r\n\r\n        const needsRepair = _.find(Memory.rooms[roomName].repairQueue, (id: string) => {\r\n            const struct: RoomObject | null = _.isUndefined(id) ? null : Game.getObjectById(id);\r\n            return !_.isNull(struct) && (!own || struct.pos.roomName === creep.memory.operateInRoom);\r\n        });\r\n\r\n        if (_.isUndefined(needsRepair)) {\r\n            return null;\r\n        }\r\n\r\n        Memory.rooms[roomName].repairQueue = _.filter(Memory.rooms[roomName].repairQueue, (id) => id !== needsRepair);\r\n\r\n        return Game.getObjectById(needsRepair);\r\n    }\r\n\r\n    /**\r\n     * @function\r\n     * Checks if creep stans on road and if not initiates road building\r\n     *\r\n     * @param {Creep} creep\r\n     */\r\n    public tryBuildRoad(creep: Creep) {\r\n        if (Memory.autoBuildRoads) {\r\n            const road = _.filter(creep.room.lookAt(creep.pos), (obj: LookAtResult) => {\r\n\r\n                return obj && obj.structure &&\r\n                    ((obj.type === LOOK_STRUCTURES && obj.structure.structureType === STRUCTURE_ROAD) ||\r\n                        obj.type === LOOK_CONSTRUCTION_SITES);\r\n            });\r\n\r\n            if (!road.length) {\r\n                creep.room.createConstructionSite(creep.pos, STRUCTURE_ROAD);\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateInfrastructure() {\r\n        _.forOwn(Game.rooms, (room) => {\r\n            if (_.isUndefined(room.memory.repairQueue)) {\r\n                room.memory.repairQueue = [];\r\n            }\r\n            if (_.isUndefined(room.memory.spawnQueue)) {\r\n                room.memory.spawnQueue = [];\r\n            }\r\n            if (_.isUndefined(room.memory.creepCount)) {\r\n                room.memory.creepCount = {};\r\n            }\r\n        });\r\n\r\n        if (_.isUndefined(Memory.harvestedSources)) {\r\n            Memory.harvestedSources = {};\r\n        }\r\n        if (_.isUndefined(Memory.autoBuildRoads)) {\r\n            Memory.autoBuildRoads = true;\r\n        }\r\n        if (_.isUndefined(Memory.maxWallHits)) {\r\n            Memory.maxWallHits = 100000;\r\n        }\r\n        if (_.isUndefined(Memory.maxRampartHits)) {\r\n            Memory.maxRampartHits = 30000;\r\n        }\r\n    }\r\n}\r\n\r\nexport const utils = new Utils();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {CARRIER, HARVESTER, rolesModule as roles} from \"./roles\";\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nclass LoopFunctions {\r\n    public findDamagedStructures() {\r\n        _.forOwn(Game.rooms, (room) => {\r\n            room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if ((struct.structureType === STRUCTURE_WALL && struct.hits < Memory.maxWallHits) ||\r\n                        (struct.structureType === STRUCTURE_RAMPART && struct.hits < Memory.maxRampartHits / 2) ||\r\n                        (struct.structureType === STRUCTURE_CONTAINER && struct.hits < struct.hitsMax - 50000) ||\r\n                        (struct.structureType !== STRUCTURE_RAMPART && struct.structureType !== STRUCTURE_WALL &&\r\n                            struct.hits < struct.hitsMax / 2)) { utils.enqueueStructure(room, struct); }\r\n                    return false;\r\n                }}); });\r\n    }\r\n\r\n    public towerLogic() {\r\n        _.forOwn(Game.structures, (struct: Structure) => {\r\n            if (struct.structureType === STRUCTURE_TOWER) {\r\n                const tower = struct as StructureTower;\r\n                const closestHostile: Creep | null = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.pos.inRangeTo(tower.pos, tower.room.memory.towerActive ? 15 : 7);\r\n                    }\r\n                });\r\n                if (closestHostile) {\r\n                    tower.room.memory.towerActive = true;\r\n                    tower.attack(closestHostile);\r\n                } else {\r\n                    tower.room.memory.towerActive = false;\r\n                }\r\n\r\n                const closestDamagedCreep: Creep | null = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.hits < creep.hitsMax / 3;\r\n                    }\r\n                });\r\n                if (closestDamagedCreep) {\r\n                    tower.heal(closestDamagedCreep);\r\n                }\r\n\r\n                if (700 < tower.energy) {\r\n                    const closestDamagedStructure: Structure | null = tower.pos.findClosestByRange(FIND_STRUCTURES, {\r\n                        filter: (structure: Structure) => {\r\n                            return (structure.structureType === STRUCTURE_RAMPART &&\r\n                                    structure.hits < Memory.maxRampartHits)\r\n                                || (structure.structureType !== STRUCTURE_WALL &&\r\n                                    structure.structureType !== STRUCTURE_RAMPART &&\r\n                                    structure.hits < structure.hitsMax / 3);\r\n                        }\r\n                    });\r\n                    if (closestDamagedStructure) {\r\n                        tower.repair(closestDamagedStructure);\r\n                    }\r\n                }\r\n\r\n                // if nothing to do heal damaged creeps\r\n                const damagedCreep: Creep | null = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n                    filter: (creep: Creep) => {\r\n                        return creep.hits < creep.hitsMax;\r\n                    }\r\n                });\r\n                if (damagedCreep) {\r\n                    tower.heal(damagedCreep);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public creepActions() {\r\n        _.forOwn(Game.creeps, (creep) => {\r\n            roles.run(creep);\r\n        });\r\n    }\r\n}\r\n\r\nconst main = new LoopFunctions();\r\n\r\nmodule.exports.loop = () => {\r\n    utils.updateInfrastructure();\r\n\r\n    utils.clearMemory();\r\n\r\n    main.findDamagedStructures();\r\n\r\n    roles.countCreeps();\r\n\r\n    _.forOwn(Game.rooms, (room) => {\r\n        if (room.controller) {\r\n\r\n            if (Object.getOwnPropertyNames(Game.creeps).length === 0) {\r\n                room.memory.spawnQueue = [];\r\n                room.memory.spawnQueue.unshift({\r\n                    body: [CARRY, MOVE],\r\n                    role: CARRIER\r\n                });\r\n                room.memory.spawnQueue.unshift({\r\n                    body: [CARRY, WORK, WORK, MOVE],\r\n                    role: HARVESTER\r\n                });\r\n            }\r\n\r\n            roles.spawn(room);\r\n        }\r\n    });\r\n\r\n    _.forOwn(Game.spawns, (spawn) => {\r\n        roles.processSpawnQueue(spawn);\r\n\r\n        if (spawn.spawning) {\r\n            const spawningCreep = Game.creeps[spawn.spawning.name];\r\n            spawn.room.visual.text(\r\n                Messages.CONSTRUCT_SYM + \" \" + spawningCreep.memory.role,\r\n                spawn.pos.x + 1,\r\n                spawn.pos.y,\r\n                {align: \"left\", opacity: 0.8});\r\n        }\r\n    });\r\n\r\n    main.towerLogic();\r\n\r\n    main.creepActions();\r\n};\r\n","import * as _ from \"lodash\";\r\n\r\nimport {limits} from \"./limits\";\r\nimport {Role} from \"./Role\";\r\n\r\nimport {roleBuilder} from \"./role.builder\";\r\nimport {roleCarrier} from \"./role.carrier\";\r\nimport {roleClaimer} from \"./role.claimer\";\r\nimport {roleHarvester} from \"./role.harvester\";\r\nimport {roleUpgrader} from \"./role.upgrader\";\r\n\r\nexport interface Roles extends _.Dictionary<Role> {\r\n    builder: Role;\r\n    carrier: Role;\r\n    claimer: Role;\r\n    harvester: Role;\r\n    upgrader: Role;\r\n}\r\n\r\nexport type CreepRole = keyof Roles;\r\n\r\nexport const BUILDER: CreepRole = \"builder\";\r\nexport const CARRIER: CreepRole = \"carrier\";\r\nexport const CLAIMER: CreepRole = \"claimer\";\r\nexport const HARVESTER: CreepRole = \"harvester\";\r\nexport const UPGRADER: CreepRole = \"upgrader\";\r\n\r\nexport const roles: Roles = {\r\n    builder:   roleBuilder,\r\n    carrier:   roleCarrier,\r\n    claimer:   roleClaimer,\r\n    harvester: roleHarvester,\r\n    upgrader:  roleUpgrader\r\n};\r\n\r\nexport interface BodySpec {\r\n    body: BodyPartConstant[];\r\n    role: CreepRole;\r\n}\r\n\r\nexport class RolesModule {\r\n    public countCreeps() {\r\n        _.forOwn(roles, (role, roleName: string) => {\r\n            _.forOwn(Memory.rooms, (roomMem) => {\r\n                roomMem.creepCount[roleName] = 0;\r\n            });\r\n        });\r\n\r\n        _.forOwn(Game.creeps, (creep) => {\r\n            if (!creep.memory.operateInRoom) {\r\n                Memory.rooms[creep.room.name].creepCount[creep.memory.role] += 1;\r\n            } else {\r\n                Memory.rooms[creep.memory.operateInRoom].creepCount[creep.memory.role] += 1;\r\n            }\r\n        });\r\n\r\n        _.forOwn(Memory.rooms, (roomMem) => {\r\n            _.forEach(roomMem.spawnQueue, (spec) => {\r\n                roomMem.creepCount[spec.role] += 1;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  @type {function}\r\n     *\r\n     *  @param {StructureSpawn} spawn Spawn on which start spawning\r\n     */\r\n    public processSpawnQueue(spawn: StructureSpawn) {\r\n        if (spawn.spawning) {\r\n            return;\r\n        }\r\n\r\n        const room = spawn.room;\r\n        const spec = room.memory.spawnQueue.shift();\r\n        if (spec) {\r\n            console.log(\"Processing spawn Q \" + spawn.name + \" \"\r\n                + JSON.stringify({room: room.name, role: spec.role}));\r\n\r\n            if (spawn.canCreateCreep(spec.body) === OK) {\r\n                const newName = spawn.createCreep(spec.body, undefined, {operateInRoom: room.name, role: spec.role});\r\n                console.log(\"Spawning new \" + spec.role + \": \" + newName);\r\n            } else if (\"claimer\" === spec.role) {\r\n                room.memory.spawnQueue.push(spec);\r\n            } else {\r\n                room.memory.spawnQueue.unshift(spec);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Creep} creep\r\n     */\r\n    public run(creep: Creep) {\r\n        roles[creep.memory.role].run(creep);\r\n    }\r\n\r\n    /**\r\n     *  @type {function}\r\n     *\r\n     *  @param {Room} room\r\n     *  @param {string|object} [role] Role of the new creep\r\n     *  @param {Array<string>} role.body Body of spawning creep\r\n     *  @param {string} role.role Role of spawning creep\r\n     */\r\n    public spawn(room: Room, role?: CreepRole | BodySpec) {\r\n        if (!role) {\r\n            _.forOwn(roles, (r, name: CreepRole) => {\r\n                if (name && room.memory.creepCount[name] < this.limit(name)) {\r\n                    const energy = room.energyAvailable;\r\n\r\n                    const body = r.body(energy);\r\n                    room.memory.spawnQueue.push({ body, role: name });\r\n                }\r\n            });\r\n        } else if (typeof role === \"string\") {\r\n            const energy = room.energyAvailable;\r\n\r\n            const body = roles[role].body(energy);\r\n            room.memory.spawnQueue.push({ body, role });\r\n        } else {\r\n            room.memory.spawnQueue.push(role as BodySpec);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} role\r\n     * @returns {number}\r\n     */\r\n    private limit(role: CreepRole): number {\r\n        if (role === \"claimer\") {\r\n            return _.isUndefined(Game.flags[\"claim\"]) && _.isUndefined(Game.flags[\"reserve\"])  ? 0 : limits[role];\r\n        } else {\r\n            return limits[role];\r\n        }\r\n    }\r\n}\r\n\r\nexport const rolesModule = new RolesModule();\r\n","import {Dictionary} from \"lodash\";\r\n\r\nexport const limits: Dictionary<number> = {\r\n    builder:   2,\r\n    carrier:   3,\r\n    claimer:   2,\r\n    harvester: 2,\r\n    upgrader:  1\r\n};\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Builder implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, CARRY, CARRY, MOVE]; // 250\r\n        } else if (availEnergy < 450) {\r\n            return [WORK, CARRY, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 550) {\r\n            return [WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE]; // 450\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE]; // 550\r\n        } else if (availEnergy < 650) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else if (availEnergy < 750) {\r\n            return [WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE]; // 650\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE]; // 750\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (!creep.memory.building && !creep.memory.energyTarget && utils.navigateToDesignatedRoom(creep)\r\n            && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n            return;\r\n        }\r\n\r\n        if (creep.memory.building && creep.carry.energy === 0) {\r\n            creep.memory.building = false;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.HARVEST);\r\n        }\r\n\r\n        if (!creep.memory.building && creep.carry.energy === creep.carryCapacity) {\r\n            creep.memory.building = true;\r\n            creep.say(Messages.BUILD);\r\n        }\r\n\r\n        if (creep.memory.building) {\r\n            let target = Game.getObjectById(creep.memory.buildTarget) as Structure | ConstructionSite | null;\r\n            if (!target) {\r\n                target = utils.shiftStructure(creep, true);\r\n\r\n                if (!target) {\r\n                    target = utils.findConstructionSite(creep);\r\n                }\r\n\r\n                if (!target) {\r\n                    target = utils.shiftStructure(creep, false);\r\n                }\r\n\r\n                if (target) {\r\n                    creep.memory.buildTarget = target.id;\r\n                } else {\r\n                    creep.say(\"\\uD83D\\uDEA7 nothing\");\r\n                    creep.memory.buildTarget = \"\";\r\n                    creep.memory.energyTarget = \"\";\r\n                    creep.memory.building = false;\r\n                }\r\n            }\r\n\r\n            if (target instanceof Structure) {\r\n                if ((target.structureType !== STRUCTURE_WALL &&\r\n                        target.structureType !== STRUCTURE_RAMPART && target.hits < target.hitsMax) ||\r\n                    (target.structureType === STRUCTURE_WALL && target.hits < Memory.maxWallHits) ||\r\n                    (target.structureType === STRUCTURE_RAMPART && target.hits < Memory.maxRampartHits)) {\r\n                    if (creep.repair(target) === ERR_NOT_IN_RANGE) {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                } else {\r\n                    creep.memory.buildTarget = \"\";\r\n                    creep.memory.building = false;\r\n                }\r\n            } else if (target instanceof ConstructionSite) {\r\n                if (creep.build(target) === ERR_NOT_IN_RANGE) {\r\n                    utils.moveTo(creep, target.pos);\r\n                }\r\n            } else {\r\n                creep.memory.buildTarget = \"\";\r\n                creep.memory.building = false;\r\n            }\r\n        } else {\r\n            if (creep.carry.energy < creep.carryCapacity) {\r\n                const target = utils.getEnergyStorageTarget(creep);\r\n                if (target) {\r\n                    const src = creep.pos.findInRange([target], 1);\r\n                    if (src.length) {\r\n                        utils.getEnergy(creep, src[0]);\r\n                    } else {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                } else {\r\n                    creep.say(\"No energy\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {Creep} creep\r\n     * @returns {ConstructionSite}\r\n     */\r\n    private findConstructionSite(type: StructureConstant, creep: Creep) {\r\n        let target = null;\r\n\r\n        const sites = _.filter(Game.constructionSites, (site: ConstructionSite) => {\r\n            return  site.structureType === type && site.pos.roomName === creep.memory.operateInRoom;\r\n        });\r\n\r\n        if (sites.length) {\r\n            target = creep.pos.findClosestByPath(sites);\r\n            if (!target) {\r\n                target = sites[0];\r\n            }\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n}\r\n\r\nexport const roleBuilder: Role = new Builder();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\n/**\r\n *\r\n * @class\r\n * @extends {Role}\r\n */\r\nclass Carrier implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        let parts;\r\n        if (availEnergy < 300) {\r\n            parts = 6;\r\n        } else if (750 < availEnergy) {\r\n            parts = 15;\r\n        } else {\r\n            parts = Math.floor(availEnergy / 50);\r\n        }\r\n\r\n        const body = new Array(parts);\r\n        const moveParts = Math.ceil(parts / 3);\r\n\r\n        for (let i = 0; i < parts; ++i) {\r\n            body[i] = i < moveParts ? MOVE : CARRY;\r\n        }\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (!creep.memory.hauling && !creep.memory.energyTarget && utils.navigateToDesignatedRoom(creep)\r\n             && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n            return;\r\n        }\r\n\r\n        if (creep.memory.hauling && creep.carry.energy === 0) {\r\n            creep.memory.hauling = false;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.PICKUP);\r\n        }\r\n\r\n        if (!creep.memory.hauling && creep.carry.energy === creep.carryCapacity) {\r\n            creep.memory.hauling = true;\r\n            creep.memory.energyTarget = \"\";\r\n            creep.say(Messages.DISTRIBUTE);\r\n        }\r\n\r\n        if (creep.memory.hauling) {\r\n            const target = this.getStoreTarget(creep);\r\n            if (target && creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            } else {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        } else {\r\n            const target = this.getEnergyTarget(creep);\r\n            if (target && utils.getEnergy(creep, target) === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            } else {\r\n                creep.memory.energyTarget = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {Resource|Source|Structure}\r\n     */\r\n    private getEnergyTarget(creep: Creep): Resource | Source | Structure | null {\r\n        let target: Structure | Resource | Source | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (target instanceof Source && creep.pos.inRangeTo(target.pos, 2)) {\r\n            target = null;\r\n        }\r\n\r\n        if (!target) {\r\n            // dropped energy\r\n            const drops: Resource[] = creep.room.find(FIND_DROPPED_RESOURCES, {\r\n                filter: (drop: Resource) => {\r\n                    return drop.resourceType === RESOURCE_ENERGY && 50 < drop.amount;\r\n                }\r\n            });\r\n\r\n            target = _.sortBy(drops, (drop: Resource) => {\r\n                return -drop.amount;\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            // containers near sources\r\n            const conts: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_CONTAINER) {\r\n                        const cont = struct as StructureContainer;\r\n                        return cont.id !== creep.room.memory.controllerCont && 20 < cont.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n\r\n            // most full container\r\n            target = _.sortBy(conts, (cont) => {\r\n                if (cont.structureType === STRUCTURE_CONTAINER) {\r\n                    const c = cont as StructureContainer;\r\n                    return c.storeCapacity - c.store.energy;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            const targets: Structure[] = creep.room.find(FIND_MY_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_STORAGE) {\r\n                        const store = struct as StructureStorage;\r\n                        return store.structureType === STRUCTURE_STORAGE && 0 < store.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n\r\n                }\r\n            });\r\n            target = targets[0];\r\n        }\r\n\r\n        if (!target) {\r\n            target = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE, {\r\n                maxOps: 100\r\n            });\r\n            if (!target) {\r\n                const targets: Source[] = creep.room.find(FIND_SOURCES);\r\n                target = targets[0];\r\n            }\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Creep} creep\r\n     * @return {Spawn|Structure}\r\n     */\r\n    private getStoreTarget(creep: Creep): Creep | Structure | null {\r\n        let target: Creep | Structure | null = Game.getObjectById(creep.memory.energyTarget);\r\n\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for spawns and extensions');\r\n            if (creep.room.energyAvailable < creep.room.energyCapacityAvailable) {\r\n                target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\r\n                    filter: (s: Structure) => {\r\n                        switch (s.structureType) {\r\n                            case STRUCTURE_SPAWN:\r\n                                const spawn = s as StructureExtension;\r\n                                return spawn.energy < spawn.energyCapacity\r\n                                    && creep.memory.operateInRoom === spawn.pos.roomName;\r\n                            case STRUCTURE_EXTENSION:\r\n                                const ext = s as StructureExtension;\r\n                                return ext.energy < ext.energyCapacity\r\n                                    && creep.memory.operateInRoom === ext.pos.roomName;\r\n                                default:\r\n                                return false;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n            // console.log('Harvester ' + creep.name + ' harvesting target: ' + target.id);\r\n\r\n        if (!target) {\r\n            // containers near controllers\r\n            // console.log('Carrier ' + creep.name + ' looking for controller container');\r\n\r\n            const designatedRoom = Game.rooms[creep.memory.operateInRoom];\r\n\r\n            const cont: StructureContainer | null =\r\n                !_.isNull(designatedRoom) ? Game.getObjectById(designatedRoom.memory.controllerCont) : null;\r\n            if (cont && 500 < cont.storeCapacity - cont.store.energy) {\r\n                target = cont;\r\n            }\r\n        }\r\n\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for towers');\r\n            const towers: Structure[] = _.filter(Game.structures, (struct: Structure) => {\r\n                if (STRUCTURE_TOWER === struct.structureType) {\r\n                    const tower = struct as StructureTower;\r\n                    return tower.room.name === creep.memory.operateInRoom &&\r\n                    0 <= tower.energyCapacity - tower.energy - 300;\r\n                } else {\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            // emptiest tower\r\n            target = _.sortBy(towers, (struct) => {\r\n                if (struct.structureType === STRUCTURE_CONTAINER) {\r\n                    const tower = struct as StructureTower;\r\n                    return tower.energyCapacity + tower.energy;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            })[0];\r\n        }\r\n\r\n        if (!target) {\r\n            // looking for storage\r\n            // console.log('Carrier ' + creep.name + ' looking for storage');\r\n            const storages: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    if (struct.structureType === STRUCTURE_STORAGE) {\r\n                        const store = struct as StructureStorage;\r\n                        return 0 < store.storeCapacity - store.store.energy;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n            target = storages[0];\r\n        }\r\n        if (!target) {\r\n            // console.log('Carrier ' + creep.name + ' looking for sources');\r\n\r\n            const targets: Structure[] = creep.room.find(FIND_STRUCTURES, {\r\n                filter: (struct: Structure) => {\r\n                    switch (struct.structureType) {\r\n                        case STRUCTURE_EXTENSION:\r\n                            const ext = struct as StructureExtension;\r\n                            return ext.energy < ext.energyCapacity && creep.memory.operateInRoom === ext.pos.roomName;\r\n                        case STRUCTURE_SPAWN:\r\n                            const spawn = struct as StructureSpawn;\r\n                            return spawn.energy < spawn.energyCapacity\r\n                                && creep.memory.operateInRoom === spawn.pos.roomName;\r\n                        default:\r\n                            return false;\r\n                    }\r\n\r\n                }\r\n            });\r\n            target = targets[0];\r\n        }\r\n\r\n        if (target) {\r\n            creep.memory.energyTarget = target.id;\r\n        }\r\n\r\n        return target;\r\n    }\r\n}\r\n\r\nexport const roleCarrier: Role = new Carrier();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\n/**\r\n *\r\n * @class\r\n * @extends {Role}\r\n */\r\nclass Claimer implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 1400) {\r\n            return [MOVE, MOVE, CLAIM];\r\n        } else {\r\n            return [MOVE, MOVE, MOVE, MOVE, CLAIM, CLAIM];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        let flag = Game.flags[\"claim\"];\r\n        if (!flag) {\r\n            flag = Game.flags[\"reserve\"];\r\n        }\r\n\r\n        const sameRoom = flag && creep.room.name === flag.pos.roomName;\r\n\r\n        if (!flag) {\r\n            delete(creep.memory.claimTarget);\r\n        }\r\n\r\n        if (flag && !sameRoom) {\r\n            utils.moveTo(creep, flag.pos);\r\n        }\r\n\r\n        if (flag && sameRoom) {\r\n            const structs = creep.room.lookForAt(LOOK_STRUCTURES, flag.pos);\r\n            if (structs.length) {\r\n                _.forEach(structs, (str: Structure) => {\r\n                    if (str.structureType === STRUCTURE_CONTROLLER) {\r\n                        creep.memory.claimTarget = str.id;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (creep.memory.claimTarget) {\r\n            // Move to target & claim\r\n            const controller: StructureController | null = Game.getObjectById(creep.memory.claimTarget);\r\n            if (controller) {\r\n                if (flag.name === \"claim\") {\r\n                    if (creep.room.controller && !creep.room.controller.my) {\r\n                        if (creep.attackController(creep.room.controller) === ERR_NOT_IN_RANGE) {\r\n                            creep.moveTo(creep.room.controller);\r\n                        }\r\n                    } else {\r\n                        if (creep.claimController(controller) !== OK) {\r\n                            utils.moveTo(creep, controller.pos);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (creep.reserveController(controller) !== OK) {\r\n                        utils.moveTo(creep, controller.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const roleClaimer: Role = new Claimer();\r\n","import * as _ from \"lodash\";\r\n\r\nimport {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Harvester implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, WORK, CARRY, MOVE]; // 300\r\n        } else if (availEnergy < 400) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 500) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 400\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 500\r\n        } else if (availEnergy < 700) {\r\n            return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 700\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        let target: Source | null = Game.getObjectById(creep.memory.target);\r\n\r\n        if (!target) {\r\n\r\n            target = this.findSource(creep);\r\n\r\n            if (target) {\r\n\r\n                if (target.room.name !== creep.room.name) {\r\n                    console.log(\"Harvester found target in other room: \" + target.room);\r\n                }\r\n\r\n                Memory.harvestedSources[target.id] = target.id;\r\n                creep.memory.target = target.id;\r\n                creep.say(Messages.HARVEST);\r\n            }\r\n        }\r\n\r\n        if (0 < creep.carry.energy) {\r\n            // console.log('Harvester ' + creep.name + ' unloading');// JSON.stringify(target, null, 4));\r\n            const dst: Structure[] = creep.pos.findInRange(FIND_STRUCTURES, 1, {\r\n                filter: (struct: StructureLink | StructureContainer) => {\r\n                    return (struct.structureType === STRUCTURE_LINK && struct.energy < struct.energyCapacity) ||\r\n                        (struct.structureType === STRUCTURE_CONTAINER && struct.store.energy < struct.storeCapacity);\r\n                }\r\n            });\r\n\r\n            if (dst.length) {\r\n                creep.transfer(dst[0], RESOURCE_ENERGY);\r\n            } else {\r\n                creep.drop(RESOURCE_ENERGY);\r\n            }\r\n        }\r\n        // console.log('Harvester ' + creep.name + ' harvesting target: ' + target.id);\r\n        // JSON.stringify(target, null, 4));\r\n        if (target) {\r\n            const err = creep.harvest(target);\r\n            if (err === ERR_NOT_IN_RANGE) {\r\n                utils.moveTo(creep, target.pos);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private findSource(creep: Creep): Source | null {\r\n        const sources: Source[] = creep.room.find(FIND_SOURCES, {\r\n            filter: (src: Source) => {\r\n                return !Memory.harvestedSources.hasOwnProperty(src.id);\r\n            }\r\n        });\r\n\r\n        return sources[0];\r\n    }\r\n}\r\n\r\nexport const roleHarvester: Role = new Harvester();\r\n","import {Messages, utils} from \"./utils\";\r\n\r\nimport {Role} from \"./Role\";\r\n\r\nclass Upgrader implements Role {\r\n    /**\r\n     * @override\r\n     */\r\n    public body(availEnergy: number) {\r\n        if (availEnergy < 350) {\r\n            return [WORK, CARRY, MOVE, MOVE]; // 250\r\n        } else if (availEnergy < 400) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE]; // 350\r\n        } else if (availEnergy < 500) {\r\n            return [WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 400\r\n        } else if (availEnergy < 600) {\r\n            return [WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 500\r\n        } else if (availEnergy < 700) {\r\n            return [WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 600\r\n        } else {\r\n            return [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE]; // 700\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public run(creep: Creep) {\r\n        utils.tryBuildRoad(creep);\r\n\r\n        if (utils.navigateToDesignatedRoom(creep) && creep.memory.operateInRoom) {\r\n            utils.moveTo(creep, new RoomPosition(25, 25, creep.memory.operateInRoom));\r\n        } else {\r\n            if (creep.memory.upgrading && creep.carry.energy === 0) {\r\n                creep.memory.upgrading = false;\r\n                creep.say(Messages.HARVEST);\r\n            }\r\n            if (!creep.memory.upgrading && creep.carry.energy === creep.carryCapacity) {\r\n                creep.memory.upgrading = true;\r\n                creep.memory.energyTarget = \"\";\r\n                creep.say(Messages.UPGRADE);\r\n            }\r\n\r\n            if (creep.memory.upgrading && creep.room.controller) {\r\n                if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {\r\n                    utils.moveTo(creep, creep.room.controller.pos);\r\n                }\r\n            } else {\r\n                const target = utils.getEnergyStorageTarget(creep);\r\n                if (target) {\r\n                    const src = creep.pos.findInRange([target], 1);\r\n                    if (src.length) {\r\n                        utils.getEnergy(creep, src[0]);\r\n                    } else {\r\n                        utils.moveTo(creep, target.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const roleUpgrader: Role = new Upgrader();\r\n"],"sourceRoot":""}